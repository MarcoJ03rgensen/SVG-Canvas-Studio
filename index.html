<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Professional SVG design and animation tool directly in your browser. Vectorize images, edit paths, and export clean SVG code.">
    <title>SVG Canvas Studio Pro | Web Editor</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- ImageTracerJS for Vectorization -->
    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        /* Custom Scrollbar for Inspector */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }
        /* Hide scrollbar for color picker row */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        /* Morph animation */
        @keyframes morphPulse {
            0%, 100% { d: path('M10,10 L90,10 L90,90 L10,90 Z'); }
            50% { d: path('M30,10 L70,10 L80,90 L20,90 Z'); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { 
            MousePointer2, Square, Circle, Type, Minus, Image as ImageIcon,
            Download, Layers, ZoomIn, ZoomOut, 
            Trash2, Copy, Play, Pause, Grid, 
            Upload, Lock, Unlock, Check, X,
            ArrowRight, Sparkles, Move, Menu, ChevronUp, ChevronDown,
            Clock, Plus, Wand2, AlignLeft, Code, Edit3, Crop,
            Scissors, RefreshCcw, LayoutTemplate, Sun, Moon, Hash, Monitor, Eye, EyeOff, MoveHorizontal
        } from 'https://esm.sh/lucide-react@0.263.1';

        const { useState, useRef, useEffect, useCallback } = React;

        // --- Assets & Constants ---

        const COLORS = {
            Gray: ['#f8fafc', '#e2e8f0', '#94a3b8', '#475569', '#1e293b', '#0f172a'],
            Red: ['#fef2f2', '#fecaca', '#f87171', '#dc2626', '#991b1b', '#450a0a'],
            Orange: ['#fff7ed', '#fed7aa', '#fb923c', '#ea580c', '#9a3412', '#431407'],
            Amber: ['#fffbeb', '#fde68a', '#fbbf24', '#d97706', '#92400e', '#451a03'],
            Green: ['#f0fdf4', '#bbf7d0', '#4ade80', '#16a34a', '#166534', '#052e16'],
            Teal: ['#f0fdfa', '#99f6e4', '#2dd4bf', '#0d9488', '#115e59', '#042f2e'],
            Blue: ['#eff6ff', '#bfdbfe', '#60a5fa', '#2563eb', '#1e40af', '#172554'],
            Indigo: ['#eef2ff', '#c7d2fe', '#818cf8', '#4f46e5', '#3730a3', '#312e81'],
            Purple: ['#faf5ff', '#e9d5ff', '#c084fc', '#9333ea', '#6b21a8', '#3b0764'],
            Pink: ['#fdf2f8', '#fbcfe8', '#f472b6', '#db2777', '#9d174d', '#500724'],
        };

        const ANIMATION_PRESETS = [
            { id: 'move', label: 'Custom Move', category: 'Motion', css: 'animation: move-{id}-{idx} {t} normal both;' },
            { id: 'fade', label: 'Fade In', category: 'Entrance', css: 'opacity: 0; animation: fadeIn {t} normal both;' },
            { id: 'scale', label: 'Pop In', category: 'Entrance', css: 'transform: scale(0); animation: scaleIn {t} normal both;' },
            { id: 'slideUp', label: 'Slide Up', category: 'Entrance', css: 'transform: translateY(50px); opacity: 0; animation: slideUp {t} normal both;' },
            { id: 'slideDown', label: 'Slide Down', category: 'Entrance', css: 'transform: translateY(-50px); opacity: 0; animation: slideDown {t} normal both;' },
            { id: 'slideLeft', label: 'Slide Left', category: 'Entrance', css: 'transform: translateX(50px); opacity: 0; animation: slideLeft {t} normal both;' },
            { id: 'slideRight', label: 'Slide Right', category: 'Entrance', css: 'transform: translateX(-50px); opacity: 0; animation: slideRight {t} normal both;' },
            { id: 'zoomIn', label: 'Zoom In', category: 'Entrance', css: 'opacity: 0; transform: scale3d(0.3, 0.3, 0.3); animation: zoomIn {t} normal both;' },
            { id: 'rotateIn', label: 'Rotate In', category: 'Entrance', css: 'opacity: 0; transform: rotate(-180deg); animation: rotateIn {t} normal both;' },
            { id: 'pulse', label: 'Pulse', category: 'Attention', css: 'animation: pulse {t} infinite;' },
            { id: 'float', label: 'Floating', category: 'Attention', css: 'animation: float {t} infinite ease-in-out;' },
            { id: 'spin', label: 'Spin', category: 'Attention', css: 'animation: spin {t} infinite linear;' },
            { id: 'bounce', label: 'Bounce', category: 'Attention', css: 'transform-origin: center bottom; animation: bounce {t} infinite;' },
            { id: 'rubberBand', label: 'Rubber Band', category: 'Attention', css: 'animation: rubberBand {t} infinite;' },
            { id: 'shake', label: 'Shake', category: 'Attention', css: 'animation: shake {t} infinite;' },
            { id: 'morph', label: 'Morph', category: 'Special', css: 'animation: morph-{id}-{idx} {t} normal both;' },
            { id: 'draw', label: 'Draw Path', category: 'Special', css: 'stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: draw {t} normal forwards;' },
            { id: 'flip', label: 'Flip', category: 'Attention', css: 'animation: flip {t} normal both;' },
            { id: 'color', label: 'Color Change', category: 'Style', css: 'animation: color-{id}-{idx} {t} normal both;' },
            { id: 'textSize', label: 'Text Size', category: 'Style', css: 'animation: textSize-{id}-{idx} {t} normal both;' },
        ];

        const SVG_TEMPLATES = [
            { id: 'logo1', name: 'Modern Circle', svg: '<circle cx="50" cy="50" r="40" fill="#6366f1" opacity="0.8"/><circle cx="50" cy="50" r="30" fill="none" stroke="#e0e7ff" stroke-width="2"/><text x="50" y="55" text-anchor="middle" font-size="20" fill="white" font-weight="bold">M</text>' },
            { id: 'logo2', name: 'Tech Star', svg: '<polygon points="50,10 61,40 92,40 67,60 79,90 50,70 21,90 33,60 8,40 39,40" fill="#ec4899"/>' },
            { id: 'shape1', name: 'Gradient Wave', svg: '<path d="M0,50 Q25,0 50,50 T100,50" stroke="#3b82f6" stroke-width="3" fill="none"/><path d="M0,60 Q25,10 50,60 T100,60" stroke="#06b6d4" stroke-width="3" fill="none" opacity="0.6"/>' },
            { id: 'shape2', name: 'Nested Squares', svg: '<rect x="10" y="10" width="80" height="80" fill="none" stroke="#8b5cf6" stroke-width="2"/><rect x="20" y="20" width="60" height="60" fill="none" stroke="#a855f7" stroke-width="2"/><rect x="30" y="30" width="40" height="40" fill="none" stroke="#d946ef" stroke-width="2"/>' },
            { id: 'icon1', name: 'Heart', svg: '<path d="M50,85 C20,65 5,50 5,35 C5,20 15,10 25,10 C35,10 50,20 50,20 C50,20 65,10 75,10 C85,10 95,20 95,35 C95,50 80,65 50,85 Z" fill="#f43f5e"/>' },
            { id: 'icon2', name: 'Lightning', svg: '<polygon points="50,5 65,35 95,35 70,60 85,95 50,65 15,95 30,60 5,35 35,35" fill="#facc15"/>' },
            { id: 'bg1', name: 'Grid Pattern', svg: '<defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="#e5e7eb" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(#grid)"/>' },
            { id: 'bg2', name: 'Radial Burst', svg: '<circle cx="50" cy="50" r="40" fill="#fbbf24" opacity="0.3"/><circle cx="50" cy="50" r="25" fill="#f59e0b" opacity="0.5"/><circle cx="50" cy="50" r="10" fill="#d97706"/>' },
        ];

        const SVG_PRESETS = [
            { id: 'preset1', name: 'Simple UI Kit', templates: ['logo1', 'shape2', 'icon1'] },
            { id: 'preset2', name: 'Abstract Art', templates: ['shape1', 'bg1', 'bg2'] },
            { id: 'preset3', name: 'Tech Icons', templates: ['logo2', 'icon2', 'shape2'] },
        ];

        const GLOBAL_STYLES = `
            @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
            @keyframes scaleIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
            @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
            @keyframes slideDown { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
            @keyframes slideLeft { from { transform: translateX(50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
            @keyframes slideRight { from { transform: translateX(-50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
            @keyframes zoomIn { from { opacity: 0; transform: scale3d(0.3, 0.3, 0.3); } 50% { opacity: 1; } }
            @keyframes rotateIn { from { opacity: 0; transform: rotate(-180deg); } to { opacity: 1; transform: rotate(0deg); } }
            @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
            @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-12px); } }
            @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
            @keyframes bounce { 0%, 20%, 53%, 80%, 100% { transform: translate3d(0,0,0); } 40%, 43% { transform: translate3d(0, -30px, 0); } 70% { transform: translate3d(0, -15px, 0); } 90% { transform: translate3d(0,-4px,0); } }
            @keyframes rubberBand { 0% { transform: scale3d(1, 1, 1); } 30% { transform: scale3d(1.25, 0.75, 1); } 40% { transform: scale3d(0.75, 1.25, 1); } 50% { transform: scale3d(1.15, 0.85, 1); } 65% { transform: scale3d(0.95, 1.05, 1); } 75% { transform: scale3d(1.05, 0.95, 1); } 100% { transform: scale3d(1, 1, 1); } }
            @keyframes shake { 0%, 100% { transform: translate3d(0, 0, 0); } 10%, 30%, 50%, 70%, 90% { transform: translate3d(-5px, 0, 0); } 20%, 40%, 60%, 80% { transform: translate3d(5px, 0, 0); } }
            @keyframes flip { 0% { transform: perspective(400px) rotateY(0); } 100% { transform: perspective(400px) rotateY(360deg); } }
            @keyframes draw { to { stroke-dashoffset: 0; } }
            @keyframes morph-pulse { 0%, 100% { transform: scale(1) rotate(0deg); } 50% { transform: scale(1.1) rotate(5deg); } }
            .canvas-obj { transform-box: fill-box; transform-origin: center; vector-effect: non-scaling-stroke; }
        `;

        const generateId = () => Math.random().toString(36).substr(2, 9);

        // --- Main Component ---
        // --- Crop & Smart Resize Tool (Ported from crop-stretch.html) ---

        const CropStretchEditor = ({ svgContent, fileName, onClose, onSave }) => {
            const containerRef = useRef(null);
            
            // Common State
            const [svgData, setSvgData] = useState({ viewBox: { x: 0, y: 0, w: 100, h: 100 }, element: null });
            const [bgMode, setBgMode] = useState('grid');
            const [zoom, setZoom] = useState(1.0);
            
            // Crop Mode State
            const [crop, setCrop] = useState({ x: 10, y: 10, width: 80, height: 80 }); 
            const [showGrid, setShowGrid] = useState(false);
            const [aspectRatio, setAspectRatio] = useState(null);
            
            // Dragging Logic
            const [isDragging, setIsDragging] = useState(false);
            const [dragState, setDragState] = useState(null); 

            // Parse SVG
            useEffect(() => {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgContent, "image/svg+xml");
                    const svg = doc.querySelector("svg");
                    
                    if (svg) {
                        const viewBoxAttr = svg.getAttribute("viewBox");
                        const widthAttr = svg.getAttribute("width");
                        const heightAttr = svg.getAttribute("height");
                        
                        let vb = { x: 0, y: 0, w: 100, h: 100 };

                        if (viewBoxAttr) {
                            const parts = viewBoxAttr.split(/[\s,]+/).filter(v => v !== '').map(parseFloat);
                            if (parts.length === 4) vb = { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
                        } else if (widthAttr && heightAttr) {
                            vb = { x: 0, y: 0, w: parseFloat(widthAttr) || 100, h: parseFloat(heightAttr) || 100 };
                        }

                        // Clean SVG for display
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('preserveAspectRatio', 'none');
                        svg.style.display = 'block';
                        if (!viewBoxAttr) svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);

                        setSvgData({ viewBox: vb, element: svg.outerHTML });
                    }
                } catch (e) {
                    console.error("Error parsing SVG", e);
                }
            }, [svgContent]);

            // Interaction Handlers
            const handleMouseDown = (e, type, handle) => {
                e.preventDefault();
                e.stopPropagation();
                
                const clientX = e.clientX || e.touches?.[0]?.clientX;
                const clientY = e.clientY || e.touches?.[0]?.clientY;
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();

                setIsDragging(true);
                setDragState({
                    type,
                    handle,
                    startX: clientX,
                    startY: clientY,
                    initialCrop: { ...crop },
                    rect
                });
            };

            const handleMouseMove = useCallback((e) => {
                if (!isDragging || !dragState) return;

                const clientX = e.clientX || e.touches?.[0]?.clientX;
                const clientY = e.clientY || e.touches?.[0]?.clientY;
                
                const dxPct = ((clientX - dragState.startX) / dragState.rect.width) * 100;
                const dyPct = ((clientY - dragState.startY) / dragState.rect.height) * 100;

                if (dragState.type === 'crop') {
                    let newCrop = { ...dragState.initialCrop };
                    const minSize = 2;

                    if (dragState.handle === 'move') {
                        newCrop.x = Math.max(0, Math.min(100 - newCrop.width, newCrop.x + dxPct));
                        newCrop.y = Math.max(0, Math.min(100 - newCrop.height, newCrop.y + dyPct));
                    } else {
                        const h = dragState.handle;
                        if (h.includes('e')) newCrop.width = Math.max(minSize, Math.min(100 - newCrop.x, newCrop.width + dxPct));
                        if (h.includes('s')) newCrop.height = Math.max(minSize, Math.min(100 - newCrop.y, newCrop.height + dyPct));
                        if (h.includes('w')) {
                            const change = Math.max(-newCrop.x, Math.min(newCrop.x + newCrop.width - minSize, dxPct));
                            newCrop.x += change;
                            newCrop.width -= change;
                        }
                        if (h.includes('n')) {
                            const change = Math.max(-newCrop.y, Math.min(newCrop.y + newCrop.height - minSize, dyPct));
                            newCrop.y += change;
                            newCrop.height -= change;
                        }

                        if (aspectRatio && h.length === 2) {
                            const vbRatio = svgData.viewBox.w / svgData.viewBox.h;
                            const visualRatio = aspectRatio / vbRatio;
                            newCrop.height = newCrop.width / visualRatio;
                        }
                    }
                    setCrop(newCrop);
                }
            }, [isDragging, dragState, aspectRatio, svgData]);

            const handleMouseUp = () => {
                setIsDragging(false);
                setDragState(null);
            };

            useEffect(() => {
                if (isDragging) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    window.addEventListener('touchmove', handleMouseMove);
                    window.addEventListener('touchend', handleMouseUp);
                }
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                    window.removeEventListener('touchmove', handleMouseMove);
                    window.removeEventListener('touchend', handleMouseUp);
                };
            }, [isDragging, handleMouseMove]);

            const generateCropSVG = () => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgContent, "image/svg+xml");
                const svg = doc.querySelector("svg");
                
                const x = (svgData.viewBox.x + (crop.x / 100) * svgData.viewBox.w);
                const y = (svgData.viewBox.y + (crop.y / 100) * svgData.viewBox.h);
                const w = ((crop.width / 100) * svgData.viewBox.w);
                const h = ((crop.height / 100) * svgData.viewBox.h);

                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
                svg.setAttribute('width', `${w}`);
                svg.setAttribute('height', `${h}`);
                svg.style.width = '';
                svg.style.height = '';

                return new XMLSerializer().serializeToString(svg);
            };

            const handleDownload = () => {
                const content = generateCropSVG();
                const blob = new Blob([content], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${fileName}-cropped.svg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const handleSendToProject = () => {
                const content = generateCropSVG();
                onSave(content);
            };

            const handleZoom = (delta) => setZoom(z => Math.max(0.5, Math.min(3.0, z + delta)));

            const containerAspectRatio = `${svgData.viewBox.w} / ${svgData.viewBox.h}`;

            return (
                <div className="flex-1 flex flex-col md:flex-row h-full overflow-hidden bg-slate-900">
                    {/* Canvas Area */}
                    <div className="flex-1 bg-slate-800/50 relative overflow-hidden flex flex-col">
                        {/* Toolbar */}
                        <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-slate-900/90 backdrop-blur border border-slate-700 p-1.5 rounded-full flex items-center gap-1 z-30 shadow-xl">
                            <button onClick={() => setBgMode('grid')} className={`p-2 rounded-full transition ${bgMode === 'grid' ? 'bg-purple-600 text-white' : 'text-slate-400 hover:bg-slate-700'}`}><Hash className="w-4 h-4" /></button>
                            <button onClick={() => setBgMode('dark')} className={`p-2 rounded-full transition ${bgMode === 'dark' ? 'bg-purple-600 text-white' : 'text-slate-400 hover:bg-slate-700'}`}><Moon className="w-4 h-4" /></button>
                            <button onClick={() => setBgMode('light')} className={`p-2 rounded-full transition ${bgMode === 'light' ? 'bg-purple-600 text-white' : 'text-slate-400 hover:bg-slate-700'}`}><Sun className="w-4 h-4" /></button>
                            <div className="w-px h-4 bg-slate-700 mx-1"></div>
                            <button onClick={() => handleZoom(-0.25)} className="p-2 rounded-full text-slate-400 hover:bg-slate-700 hover:text-white transition"><ZoomOut className="w-4 h-4" /></button>
                            <span className="text-[10px] font-mono text-slate-400 min-w-[32px] text-center">{Math.round(zoom * 100)}%</span>
                            <button onClick={() => handleZoom(0.25)} className="p-2 rounded-full text-slate-400 hover:bg-slate-700 hover:text-white transition"><ZoomIn className="w-4 h-4" /></button>
                        </div>

                        {/* Background */}
                        <div className="absolute inset-0 z-0 pointer-events-none transition-colors duration-300"
                            style={{
                                backgroundColor: bgMode === 'light' ? '#f1f5f9' : bgMode === 'dark' ? '#0f172a' : '#334155',
                                backgroundImage: bgMode === 'grid' ? `linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px)` : 'none',
                                backgroundSize: '24px 24px',
                            }}
                        />

                        {/* Content */}
                        <div className="flex-1 overflow-auto flex items-center justify-center p-8">
                            <div ref={containerRef} className="relative shadow-2xl shadow-black/50 transition-all duration-200"
                                style={{ width: '100%', maxHeight: `${75 * zoom}vh`, maxWidth: `${90 * zoom}%`, aspectRatio: containerAspectRatio }}>
                                
                                <div className="w-full h-full pointer-events-none [&>svg]:w-full [&>svg]:h-full" dangerouslySetInnerHTML={{ __html: svgData.element }} />
                                <div className="absolute inset-0 bg-slate-900/60 pointer-events-none"><div style={{ position: 'absolute', left: `${crop.x}%`, top: `${crop.y}%`, width: `${crop.width}%`, height: `${crop.height}%`, boxShadow: '0 0 0 9999px rgba(15, 23, 42, 0.6)' }} /></div>
                                <div className="absolute z-10 group" style={{ left: `${crop.x}%`, top: `${crop.y}%`, width: `${crop.width}%`, height: `${crop.height}%`, cursor: 'move' }} onMouseDown={(e) => handleMouseDown(e, 'crop', 'move')} onTouchStart={(e) => handleMouseDown(e, 'crop', 'move')}>
                                    <div className="absolute inset-0 border-2 border-purple-400 shadow-[0_0_0_1px_rgba(0,0,0,0.5)]"></div>
                                    <div className={`absolute inset-0 transition-opacity pointer-events-none ${showGrid || isDragging ? 'opacity-100' : 'opacity-0 group-hover:opacity-40'}`}>
                                        <div className="absolute left-1/3 top-0 bottom-0 w-px bg-purple-400/50"></div>
                                        <div className="absolute right-1/3 top-0 bottom-0 w-px bg-purple-400/50"></div>
                                        <div className="absolute top-1/3 left-0 right-0 h-px bg-purple-400/50"></div>
                                        <div className="absolute bottom-1/3 left-0 right-0 h-px bg-purple-400/50"></div>
                                    </div>
                                    {[{ pos: 'nw', cursor: 'nw-resize', class: '-top-1.5 -left-1.5' }, { pos: 'ne', cursor: 'ne-resize', class: '-top-1.5 -right-1.5' }, { pos: 'sw', cursor: 'sw-resize', class: '-bottom-1.5 -left-1.5' }, { pos: 'se', cursor: 'se-resize', class: '-bottom-1.5 -right-1.5' }, { pos: 'n', cursor: 'n-resize', class: '-top-1.5 left-1/2 -translate-x-1/2' }, { pos: 's', cursor: 's-resize', class: '-bottom-1.5 left-1/2 -translate-x-1/2' }, { pos: 'e', cursor: 'e-resize', class: '-right-1.5 top-1/2 -translate-y-1/2' }, { pos: 'w', cursor: 'w-resize', class: '-left-1.5 top-1/2 -translate-y-1/2' }].filter(h => !aspectRatio || h.pos.length === 2).map((h) => (
                                        <div key={h.pos} className={`absolute w-3 h-3 bg-purple-500 border border-white rounded-full z-20 ${h.class}`} style={{ cursor: h.cursor }} onMouseDown={(e) => handleMouseDown(e, 'crop', h.pos)} onTouchStart={(e) => handleMouseDown(e, 'crop', h.pos)} />
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Sidebar */}
                    <div className="w-full md:w-80 bg-slate-900 border-t md:border-t-0 md:border-l border-slate-700 flex flex-col z-20 shadow-xl overflow-y-auto">
                        <div className="p-6 space-y-8">
                            <div>
                                <h2 className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">Crop Ratio</h2>
                                <div className="grid grid-cols-4 gap-2 mb-4">
                                    <button onClick={() => setAspectRatio(null)} className={`p-2 rounded-md text-xs font-medium border transition-colors flex flex-col items-center gap-1 ${aspectRatio === null ? 'bg-purple-600 border-purple-500 text-white' : 'border-slate-700 text-slate-400 hover:bg-slate-800'}`}><LayoutTemplate className="w-4 h-4" /> Free</button>
                                    <button onClick={() => setAspectRatio(1)} className={`p-2 rounded-md text-xs font-medium border transition-colors flex flex-col items-center gap-1 ${aspectRatio === 1 ? 'bg-purple-600 border-purple-500 text-white' : 'border-slate-700 text-slate-400 hover:bg-slate-800'}`}><Square className="w-4 h-4" /> 1:1</button>
                                    <button onClick={() => setAspectRatio(16/9)} className={`p-2 rounded-md text-xs font-medium border transition-colors flex flex-col items-center gap-1 ${aspectRatio === 16/9 ? 'bg-purple-600 border-purple-500 text-white' : 'border-slate-700 text-slate-400 hover:bg-slate-800'}`}><Monitor className="w-4 h-4" /> 16:9</button>
                                    <button onClick={() => setAspectRatio(4/3)} className={`p-2 rounded-md text-xs font-medium border transition-colors flex flex-col items-center gap-1 ${aspectRatio === 4/3 ? 'bg-purple-600 border-purple-500 text-white' : 'border-slate-700 text-slate-400 hover:bg-slate-800'}`}><Monitor className="w-4 h-4" /> 4:3</button>
                                </div>
                            </div>
                            
                            <div className="pt-4 border-t border-slate-700 mt-auto flex flex-col gap-3">
                                <button onClick={() => setCrop({ x: 0, y: 0, width: 100, height: 100 })} className="w-full py-3 px-4 bg-slate-800 hover:bg-slate-700 text-slate-300 rounded-lg font-medium transition-colors flex items-center justify-center gap-2"><RefreshCcw className="w-4 h-4" /> Reset Crop</button>
                                <button onClick={handleDownload} className="w-full py-3 px-4 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-bold transition-all flex items-center justify-center gap-2"><Download className="w-5 h-5" /> Export SVG</button>
                                <button onClick={handleSendToProject} className="w-full py-3 px-4 bg-purple-600 hover:bg-purple-500 text-white rounded-lg font-bold shadow-lg shadow-purple-600/20 transition-all flex items-center justify-center gap-2"><Check className="w-5 h-5" /> Send to Project</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const CropStretchModal = ({ onClose, onSave }) => {
            const [svgContent, setSvgContent] = useState(null);
            const [fileName, setFileName] = useState('');

            const handleFileUpload = (event) => {
                const file = event.target.files?.[0];
                if (file && file.type === 'image/svg+xml') {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setSvgContent(e.target.result);
                        setFileName(file.name.replace('.svg', ''));
                    };
                    reader.readAsText(file);
                } else {
                    alert("Please upload a valid SVG file.");
                }
            };

            return (
                <div className="fixed inset-0 z-50 bg-slate-900/90 backdrop-blur-sm flex items-center justify-center p-4">
                    <div className="bg-slate-900 w-full h-full max-w-6xl max-h-[90vh] rounded-2xl border border-slate-700 shadow-2xl overflow-hidden flex flex-col">
                        <header className="flex justify-between items-center px-6 py-4 border-b border-slate-700 bg-slate-900/50">
                            <div className="flex items-center gap-3">
                                <div className="p-2 bg-purple-600 rounded-lg shadow-lg shadow-purple-500/20"><Crop className="w-6 h-6 text-white" /></div>
                                <h1 className="text-xl font-bold text-white">Crop Tool</h1>
                            </div>
                            <button onClick={onClose} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white transition-colors"><X className="w-5 h-5" /></button>
                        </header>
                        
                        <main className="flex-1 flex flex-col overflow-hidden">
                            {!svgContent ? (
                                <div className="flex-1 flex items-center justify-center p-6">
                                    <div className="w-full max-w-2xl border-2 border-dashed border-slate-700 rounded-2xl bg-slate-800/30 hover:bg-slate-800/50 hover:border-purple-500/50 transition-all duration-300 group cursor-pointer relative h-96 flex flex-col items-center justify-center">
                                        <input type="file" accept=".svg" onChange={handleFileUpload} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" />
                                        <div className="w-20 h-20 bg-slate-700/50 rounded-full flex items-center justify-center mb-6 group-hover:scale-110 group-hover:bg-slate-700 transition-all duration-300"><Upload className="w-10 h-10 text-purple-400" /></div>
                                        <h3 className="text-xl font-semibold text-white mb-2">Upload SVG File</h3>
                                        <p className="text-slate-400 max-w-sm text-center px-4">Drag and drop or click to select a vector file to crop.</p>
                                    </div>
                                </div>
                            ) : (
                                <CropStretchEditor svgContent={svgContent} fileName={fileName} onClose={onClose} onSave={onSave} />
                            )}
                        </main>
                    </div>
                </div>
            );
        };

        function CanvasStudioUltimate() {
            // --- State ---
            const [elements, setElements] = useState([]);
            const [selection, setSelection] = useState(null); 
            const [view, setView] = useState({ x: 0, y: 0, zoom: 1 });
            const [tool, setTool] = useState('select'); 
            const [isPlaying, setIsPlaying] = useState(false);
            const [showGrid, setShowGrid] = useState(true);
            const [isDragging, setIsDragging] = useState(false);
            const [dragAction, setDragAction] = useState(null);
            const [showIntro, setShowIntro] = useState(true);
            const [isInspectorOpen, setIsInspectorOpen] = useState(false);
            const [activeTab, setActiveTab] = useState('properties');
            const [showTemplates, setShowTemplates] = useState(false);
            const [showSVGEditor, setShowSVGEditor] = useState(false);
            const [svgEditorContent, setSvgEditorContent] = useState('');
            const [isProcessingImage, setIsProcessingImage] = useState(false);
            const [editMode, setEditMode] = useState(false); // For path editing
            const [showShapeMenu, setShowShapeMenu] = useState(false);
            const [multiSelection, setMultiSelection] = useState([]); // Array of selected IDs
            const [showLayersPanel, setShowLayersPanel] = useState(false);
            const [draggedAnimIndex, setDraggedAnimIndex] = useState(null);
            const [smartGuidesEnabled, setSmartGuidesEnabled] = useState(true);
            const [activeGuides, setActiveGuides] = useState([]);
            const [defaultShapeStyle, setDefaultShapeStyle] = useState({ fill: '#3b82f6', stroke: 'none', strokeWidth: 0 });
            const [selectedPointIndices, setSelectedPointIndices] = useState(new Set());
            const [selectionBox, setSelectionBox] = useState(null);
            const [showCropTool, setShowCropTool] = useState(false);

            const handleCropToolSave = (newSvgContent) => {
                try {
                    // Parse dimensions from the SVG string
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(newSvgContent, 'image/svg+xml');
                    const svg = doc.querySelector('svg');
                    
                    // Get dimensions or default
                    let width = parseFloat(svg.getAttribute('width'));
                    let height = parseFloat(svg.getAttribute('height'));
                    const viewBox = svg.getAttribute('viewBox');
                    
                    if ((isNaN(width) || isNaN(height)) && viewBox) {
                        const [, , vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
                        if (!isNaN(vbW)) width = vbW;
                        if (!isNaN(vbH)) height = vbH;
                    }
                    
                    if (isNaN(width)) width = 200;
                    if (isNaN(height)) height = 200;

                    // Create Data URI to preserve exact fidelity
                    const base64 = btoa(unescape(encodeURIComponent(newSvgContent)));
                    const dataUri = `data:image/svg+xml;base64,${base64}`;
                    
                    // Calculate center position
                    const centerX = -view.x / view.zoom;
                    const centerY = -view.y / view.zoom;

                    const newEl = {
                        id: generateId(),
                        type: 'image',
                        x: centerX - width / 2,
                        y: centerY - height / 2,
                        width: width,
                        height: height,
                        href: dataUri,
                        rotation: 0,
                        opacity: 1,
                        locked: false,
                        visible: true,
                        fill: 'none',
                        stroke: 'none'
                    };

                    setElements(prev => [...prev, newEl]);
                    setShowCropTool(false);
                } catch (err) {
                    console.error("SVG parsing error:", err);
                    alert("Failed to import cropped SVG.");
                }
            };

            // --- New Features State ---
            const [editTool, setEditTool] = useState('none'); // 'none', 'points', 'crop', 'slice'
            const [sliceConfig, setSliceConfig] = useState(null); // { x: {start, end}, y: {start, end} } for active element
            
            const svgRef = useRef(null);
            const containerRef = useRef(null);
            const dragStartRef = useRef({ x: 0, y: 0, elState: null }); 

            // --- Web Deployment Safety ---
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (elements.length > 0) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [elements]);

            // Reset edit tool when selection changes
            useEffect(() => {
                setEditTool('none');
                setSelectedPointIndices(new Set());
            }, [selection]);

            // Close shape menu when clicking outside
            useEffect(() => {
                const handleClick = (e) => {
                    if (showShapeMenu && !e.target.closest('.shape-menu-container')) {
                        setShowShapeMenu(false);
                    }
                };
                document.addEventListener('mousedown', handleClick);
                return () => document.removeEventListener('mousedown', handleClick);
            }, [showShapeMenu]);

            // --- Helpers ---
            
            const getPointerPos = (e) => {
                if (!svgRef.current) return { x: 0, y: 0 };
                const pt = svgRef.current.createSVGPoint();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                pt.x = clientX;
                pt.y = clientY;
                return pt.matrixTransform(svgRef.current.getScreenCTM().inverse());
            };

            // Smart Guides: Detect alignments between moving element and other elements
            const detectAlignments = (movingEl, movingBBox) => {
                if (!smartGuidesEnabled) return { guides: [], snapOffsets: { x: 0, y: 0 } };
                
                const SNAP_THRESHOLD = 5; // pixels
                const guides = [];
                let snapOffsetX = 0, snapOffsetY = 0;
                let minDistX = SNAP_THRESHOLD, minDistY = SNAP_THRESHOLD;
                
                // Get all other elements (excluding the moving one and its descendants)
                const otherElements = elements.filter(el => {
                    if (el.id === movingEl.id) return false;
                    if (el.type === 'group' && el.children?.some(c => c.id === movingEl.id)) return false;
                    return el.visible && !el.locked;
                });
                
                // Calculate edges for moving element
                const mLeft = movingBBox.x;
                const mRight = movingBBox.x + movingBBox.width;
                const mCenterX = movingBBox.x + movingBBox.width / 2;
                const mTop = movingBBox.y;
                const mBottom = movingBBox.y + movingBBox.height;
                const mCenterY = movingBBox.y + movingBBox.height / 2;
                
                otherElements.forEach(el => {
                    const bbox = getBoundingBox(el);
                    const oLeft = bbox.x;
                    const oRight = bbox.x + bbox.width;
                    const oCenterX = bbox.x + bbox.width / 2;
                    const oTop = bbox.y;
                    const oBottom = bbox.y + bbox.height;
                    const oCenterY = bbox.y + bbox.height / 2;
                    
                    // Check horizontal alignments
                    const checkH = (mVal, oVal, label) => {
                        const dist = Math.abs(mVal - oVal);
                        if (dist < minDistX) {
                            minDistX = dist;
                            snapOffsetX = oVal - mVal;
                            guides.length = 0; // Clear previous guides
                            guides.push({
                                type: 'vertical',
                                x: oVal,
                                y1: Math.min(mTop, oTop),
                                y2: Math.max(mBottom, oBottom),
                                label
                            });
                        } else if (dist === minDistX) {
                            guides.push({
                                type: 'vertical',
                                x: oVal,
                                y1: Math.min(mTop, oTop),
                                y2: Math.max(mBottom, oBottom),
                                label
                            });
                        }
                    };
                    
                    // Check vertical alignments
                    const checkV = (mVal, oVal, label) => {
                        const dist = Math.abs(mVal - oVal);
                        if (dist < minDistY) {
                            minDistY = dist;
                            snapOffsetY = oVal - mVal;
                            // Filter out horizontal guides
                            const vertGuides = guides.filter(g => g.type === 'vertical');
                            guides.length = 0;
                            guides.push(...vertGuides);
                            guides.push({
                                type: 'horizontal',
                                y: oVal,
                                x1: Math.min(mLeft, oLeft),
                                x2: Math.max(mRight, oRight),
                                label
                            });
                        } else if (dist === minDistY) {
                            guides.push({
                                type: 'horizontal',
                                y: oVal,
                                x1: Math.min(mLeft, oLeft),
                                x2: Math.max(mRight, oRight),
                                label
                            });
                        }
                    };
                    
                    // Check all alignment combinations
                    checkH(mLeft, oLeft, 'left');
                    checkH(mLeft, oRight, 'left-right');
                    checkH(mRight, oRight, 'right');
                    checkH(mRight, oLeft, 'right-left');
                    checkH(mCenterX, oCenterX, 'center');
                    
                    checkV(mTop, oTop, 'top');
                    checkV(mTop, oBottom, 'top-bottom');
                    checkV(mBottom, oBottom, 'bottom');
                    checkV(mBottom, oTop, 'bottom-top');
                    checkV(mCenterY, oCenterY, 'middle');
                });
                
                return {
                    guides: minDistX < SNAP_THRESHOLD || minDistY < SNAP_THRESHOLD ? guides : [],
                    snapOffsets: {
                        x: minDistX < SNAP_THRESHOLD ? snapOffsetX : 0,
                        y: minDistY < SNAP_THRESHOLD ? snapOffsetY : 0
                    }
                };
            };

            const addElement = (type, extraProps = {}) => {
                const containerW = containerRef.current?.clientWidth || 800;
                const containerH = containerRef.current?.clientHeight || 600;
                // Center of the screen in SVG coordinates (0,0 is now center of canvas)
                const centerX = -view.x / view.zoom;
                const centerY = -view.y / view.zoom;

                const baseEl = {
                    id: generateId(),
                    type,
                    x: centerX - 50,
                    y: centerY - 50,
                    width: 100,
                    height: 100,
                    rotation: 0,
                    opacity: 1,
                    visible: true,
                    locked: false,
                    fill: type === 'line' ? 'none' : defaultShapeStyle.fill,
                    fillType: 'solid',
                    gradientStops: [
                        { offset: 0, color: '#3b82f6' },
                        { offset: 100, color: '#60a5fa' }
                    ],
                    stroke: type === 'line' ? '#1e293b' : defaultShapeStyle.stroke,
                    strokeWidth: type === 'line' ? 4 : (defaultShapeStyle.strokeWidth || 0),
                    strokeDash: 0,
                    borderRadius: 0,
                    shadow: false,
                    text: 'Double click to edit',
                    fontSize: 24,
                    fontFamily: 'Inter, sans-serif',
                    fontWeight: 'normal',
                    textAlign: 'start',
                    x2: centerX + 50,
                    y2: centerY + 50,
                    markerEnd: 'none',
                    animations: [],
                    points: null, // For path editing
                    ...extraProps
                };

                if (type === 'circle') baseEl.borderRadius = 50;
                if (type === 'text') { baseEl.width = 250; baseEl.height = 40; baseEl.fill = '#1e293b'; }
                
                // Initialize points for editable shapes
                if (type === 'polygon') {
                    baseEl.points = [{x: 50, y: 0}, {x: 100, y: 100}, {x: 0, y: 100}];
                    baseEl.width = 100;
                    baseEl.height = 100;
                } else if (type === 'triangle') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 50, y: 0}, {x: 100, y: 100}, {x: 0, y: 100}];
                } else if (type === 'pentagon') {
                    baseEl.type = 'polygon';
                    const pts = [];
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                        pts.push({ x: 50 + 50 * Math.cos(angle), y: 50 + 50 * Math.sin(angle) });
                    }
                    baseEl.points = pts;
                } else if (type === 'hexagon') {
                    baseEl.type = 'polygon';
                    const pts = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 2 * Math.PI / 6) - Math.PI / 2;
                        pts.push({ x: 50 + 50 * Math.cos(angle), y: 50 + 50 * Math.sin(angle) });
                    }
                    baseEl.points = pts;
                } else if (type === 'octagon') {
                    baseEl.type = 'polygon';
                    const pts = [];
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * 2 * Math.PI / 8) - Math.PI / 2;
                        pts.push({ x: 50 + 50 * Math.cos(angle), y: 50 + 50 * Math.sin(angle) });
                    }
                    baseEl.points = pts;
                } else if (type === 'star') {
                    baseEl.type = 'polygon';
                    const pts = [];
                    for (let i = 0; i < 10; i++) {
                        const angle = (i * Math.PI / 5) - Math.PI / 2;
                        const radius = i % 2 === 0 ? 50 : 25;
                        pts.push({ x: 50 + radius * Math.cos(angle), y: 50 + radius * Math.sin(angle) });
                    }
                    baseEl.points = pts;
                } else if (type === 'heart') {
                    baseEl.type = 'path';
                    baseEl.commands = [
                        { type: 'M', x: 50, y: 30 },
                        { type: 'C', x1: 50, y1: 20, x2: 35, y2: 10, x: 25, y: 10 },
                        { type: 'C', x1: 10, y1: 10, x2: 0, y2: 20, x: 0, y: 35 },
                        { type: 'C', x1: 0, y1: 50, x2: 20, y2: 70, x: 50, y: 95 },
                        { type: 'C', x1: 80, y1: 70, x2: 100, y2: 50, x: 100, y: 35 },
                        { type: 'C', x1: 100, y1: 20, x2: 90, y2: 10, x: 75, y: 10 },
                        { type: 'C', x1: 65, y1: 10, x2: 50, y2: 20, x: 50, y: 30 },
                        { type: 'Z' }
                    ];
                } else if (type === 'diamond') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 50, y: 0}, {x: 100, y: 50}, {x: 50, y: 100}, {x: 0, y: 50}];
                } else if (type === 'arrow-right') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 0, y: 30}, {x: 60, y: 30}, {x: 60, y: 0}, {x: 100, y: 50}, {x: 60, y: 100}, {x: 60, y: 70}, {x: 0, y: 70}];
                } else if (type === 'arrow-left') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 100, y: 30}, {x: 40, y: 30}, {x: 40, y: 0}, {x: 0, y: 50}, {x: 40, y: 100}, {x: 40, y: 70}, {x: 100, y: 70}];
                } else if (type === 'arrow-up') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 30, y: 100}, {x: 30, y: 40}, {x: 0, y: 40}, {x: 50, y: 0}, {x: 100, y: 40}, {x: 70, y: 40}, {x: 70, y: 100}];
                } else if (type === 'arrow-down') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 30, y: 0}, {x: 30, y: 60}, {x: 0, y: 60}, {x: 50, y: 100}, {x: 100, y: 60}, {x: 70, y: 60}, {x: 70, y: 0}];
                } else if (type === 'cross') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 30, y: 0}, {x: 70, y: 0}, {x: 70, y: 30}, {x: 100, y: 30}, {x: 100, y: 70}, {x: 70, y: 70}, {x: 70, y: 100}, {x: 30, y: 100}, {x: 30, y: 70}, {x: 0, y: 70}, {x: 0, y: 30}, {x: 30, y: 30}];
                } else if (type === 'lightning') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 60, y: 0}, {x: 30, y: 50}, {x: 50, y: 50}, {x: 40, y: 100}, {x: 70, y: 50}, {x: 50, y: 50}];
                } else if (type === 'cloud') {
                    baseEl.type = 'path';
                    baseEl.commands = [
                        { type: 'M', x: 25, y: 60 },
                        { type: 'C', x1: 25, y1: 50, x2: 15, y2: 40, x: 25, y: 35 },
                        { type: 'C', x1: 25, y1: 15, x2: 45, y2: 0, x: 60, y: 10 },
                        { type: 'C', x1: 75, y1: 0, x2: 90, y2: 15, x: 85, y: 35 },
                        { type: 'C', x1: 95, y1: 40, x2: 95, y2: 50, x: 85, y: 60 },
                        { type: 'Z' }
                    ];
                } else if (type === 'right-triangle') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 0, y: 0}, {x: 0, y: 100}, {x: 100, y: 100}];
                } else if (type === 'parallelogram') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 25, y: 0}, {x: 100, y: 0}, {x: 75, y: 100}, {x: 0, y: 100}];
                } else if (type === 'trapezoid') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 25, y: 0}, {x: 75, y: 0}, {x: 100, y: 100}, {x: 0, y: 100}];
                } else if (type === 'chevron-right') {
                    baseEl.type = 'polygon';
                    baseEl.points = [{x: 0, y: 0}, {x: 75, y: 50}, {x: 0, y: 100}, {x: 25, y: 50}];
                } else if (type === 'speech-bubble') {
                    baseEl.type = 'path';
                    baseEl.commands = [
                        { type: 'M', x: 10, y: 10 },
                        { type: 'L', x: 90, y: 10 },
                        { type: 'Q', x: 100, y: 10, x: 100, y: 20 },
                        { type: 'L', x: 100, y: 70 },
                        { type: 'Q', x: 100, y: 80, x: 90, y: 80 },
                        { type: 'L', x: 40, y: 80 },
                        { type: 'L', x: 20, y: 100 },
                        { type: 'L', x: 30, y: 80 },
                        { type: 'L', x: 10, y: 80 },
                        { type: 'Q', x: 0, y: 80, x: 0, y: 70 },
                        { type: 'L', x: 0, y: 20 },
                        { type: 'Q', x: 0, y: 10, x: 10, y: 10 },
                        { type: 'Z' }
                    ];
                } else if (type === 'check') {
                    baseEl.type = 'path';
                    baseEl.commands = [
                        { type: 'M', x: 10, y: 50 },
                        { type: 'L', x: 40, y: 80 },
                        { type: 'L', x: 90, y: 20 },
                        { type: 'L', x: 80, y: 10 },
                        { type: 'L', x: 40, y: 60 },
                        { type: 'L', x: 20, y: 40 },
                        { type: 'Z' }
                    ];
                } else if (type === 'x-mark') {
                    baseEl.type = 'path';
                    baseEl.commands = [
                        { type: 'M', x: 20, y: 10 },
                        { type: 'L', x: 50, y: 40 },
                        { type: 'L', x: 80, y: 10 },
                        { type: 'L', x: 90, y: 20 },
                        { type: 'L', x: 60, y: 50 },
                        { type: 'L', x: 90, y: 80 },
                        { type: 'L', x: 80, y: 90 },
                        { type: 'L', x: 50, y: 60 },
                        { type: 'L', x: 20, y: 90 },
                        { type: 'L', x: 10, y: 80 },
                        { type: 'L', x: 40, y: 50 },
                        { type: 'L', x: 10, y: 20 },
                        { type: 'Z' }
                    ];
                } else if (type === 'moon') {
                    baseEl.type = 'path';
                    baseEl.commands = [
                        { type: 'M', x: 50, y: 10 },
                        { type: 'C', x1: 20, y1: 10, x2: 20, y2: 90, x: 50, y: 90 },
                        { type: 'C', x1: 40, y1: 80, x2: 40, y2: 20, x: 50, y: 10 },
                        { type: 'Z' }
                    ];
                } else if (type === 'cylinder') {
                    baseEl.type = 'path';
                    // Simplified cylinder path that works better with fill
                    baseEl.commands = [
                        { type: 'M', x: 10, y: 20 },
                        { type: 'L', x: 10, y: 80 },
                        { type: 'C', x1: 10, y1: 90, x2: 90, y2: 90, x: 90, y: 80 },
                        { type: 'L', x: 90, y: 20 },
                        { type: 'C', x1: 90, y1: 30, x2: 10, y2: 30, x: 10, y: 20 },
                        { type: 'Z' },
                        { type: 'M', x: 10, y: 20 },
                        { type: 'C', x1: 10, y1: 10, x2: 90, y2: 10, x: 90, y: 20 },
                        { type: 'C', x1: 90, y1: 30, x2: 10, y2: 30, x: 10, y: 20 }
                    ];
                } else if (type === 'cube') {
                    baseEl.type = 'path';
                    // Simplified cube path
                    baseEl.commands = [
                        { type: 'M', x: 25, y: 25 },
                        { type: 'L', x: 75, y: 25 },
                        { type: 'L', x: 75, y: 75 },
                        { type: 'L', x: 25, y: 75 },
                        { type: 'Z' },
                        { type: 'M', x: 25, y: 25 },
                        { type: 'L', x: 50, y: 0 },
                        { type: 'L', x: 100, y: 0 },
                        { type: 'L', x: 75, y: 25 },
                        { type: 'M', x: 100, y: 0 },
                        { type: 'L', x: 100, y: 50 },
                        { type: 'L', x: 75, y: 75 }
                    ];
                } else if (type === 'bracket-curly-left') {
                    baseEl.type = 'path';
                    baseEl.fill = 'none';
                    baseEl.strokeWidth = 4;
                    baseEl.commands = [
                        { type: 'M', x: 60, y: 10 },
                        { type: 'Q', x1: 40, y1: 10, x: 40, y: 30 },
                        { type: 'L', x: 40, y: 45 },
                        { type: 'Q', x1: 40, y1: 55, x: 20, y: 55 },
                        { type: 'Q', x1: 40, y1: 55, x: 40, y: 65 },
                        { type: 'L', x: 40, y: 80 },
                        { type: 'Q', x1: 40, y1: 100, x: 60, y: 100 }
                    ];
                } else if (type === 'bracket-curly-right') {
                    baseEl.type = 'path';
                    baseEl.fill = 'none';
                    baseEl.strokeWidth = 4;
                    baseEl.commands = [
                        { type: 'M', x: 40, y: 10 },
                        { type: 'Q', x1: 60, y1: 10, x: 60, y: 30 },
                        { type: 'L', x: 60, y: 45 },
                        { type: 'Q', x1: 60, y1: 55, x: 80, y: 55 },
                        { type: 'Q', x1: 60, y1: 55, x: 60, y: 65 },
                        { type: 'L', x: 60, y: 80 },
                        { type: 'Q', x1: 60, y1: 100, x: 40, y: 100 }
                    ];
                } else if (type === 'bracket-square-left') {
                    baseEl.type = 'path';
                    baseEl.fill = 'none';
                    baseEl.strokeWidth = 4;
                    baseEl.commands = [
                        { type: 'M', x: 60, y: 10 },
                        { type: 'L', x: 40, y: 10 },
                        { type: 'L', x: 40, y: 100 },
                        { type: 'L', x: 60, y: 100 }
                    ];
                } else if (type === 'bracket-square-right') {
                    baseEl.type = 'path';
                    baseEl.fill = 'none';
                    baseEl.strokeWidth = 4;
                    baseEl.commands = [
                        { type: 'M', x: 40, y: 10 },
                        { type: 'L', x: 60, y: 10 },
                        { type: 'L', x: 60, y: 100 },
                        { type: 'L', x: 40, y: 100 }
                    ];
                } else if (type === 'parenthesis-left') {
                    baseEl.type = 'path';
                    baseEl.fill = 'none';
                    baseEl.strokeWidth = 4;
                    baseEl.commands = [
                        { type: 'M', x: 60, y: 10 },
                        { type: 'Q', x1: 30, y1: 55, x: 60, y: 100 }
                    ];
                } else if (type === 'parenthesis-right') {
                    baseEl.type = 'path';
                    baseEl.fill = 'none';
                    baseEl.strokeWidth = 4;
                    baseEl.commands = [
                        { type: 'M', x: 40, y: 10 },
                        { type: 'Q', x1: 70, y1: 55, x: 40, y: 100 }
                    ];
                }

                setElements(prev => [...prev, baseEl]);
                setSelection(baseEl.id);
                setIsInspectorOpen(true);
                setTool('select');
            };

            const updateElement = (id, updates) => {
                const updateRecursive = (list) => {
                    return list.map(el => {
                        if (el.id === id) return { ...el, ...updates };
                        if (el.children) return { ...el, children: updateRecursive(el.children) };
                        return el;
                    });
                };
                setElements(prev => updateRecursive(prev));
            };

            const removeElement = (id) => {
                const removeRecursive = (list) => {
                    return list.filter(el => el.id !== id).map(el => {
                        if (el.children) return { ...el, children: removeRecursive(el.children) };
                        return el;
                    });
                };
                setElements(prev => removeRecursive(prev));
                if (selection === id) {
                    setSelection(null);
                    setIsInspectorOpen(false);
                }
            };

            const findElement = (id, list = elements) => {
                for (let el of list) {
                    if (el.id === id) return el;
                    if (el.children) {
                        const found = findElement(id, el.children);
                        if (found) return found;
                    }
                }
                return null;
            };

            const getBoundingBox = (el) => {
                if (el.type === 'group' && el.children) {
                    if (el.children.length === 0) return { x: el.x, y: el.y, width: el.width || 0, height: el.height || 0 };
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    el.children.forEach(child => {
                        const bbox = getBoundingBox(child);
                        minX = Math.min(minX, el.x + bbox.x);
                        minY = Math.min(minY, el.y + bbox.y);
                        maxX = Math.max(maxX, el.x + bbox.x + bbox.width);
                        maxY = Math.max(maxY, el.y + bbox.y + bbox.height);
                    });
                    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                }
                
                if (el.type === 'polygon' && el.points) {
                    const xs = el.points.map(p => el.x + p.x);
                    const ys = el.points.map(p => el.y + p.y);
                    return {
                        x: Math.min(...xs),
                        y: Math.min(...ys),
                        width: Math.max(...xs) - Math.min(...xs),
                        height: Math.max(...ys) - Math.min(...ys)
                    };
                } else if (el.type === 'path' && el.commands) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    el.commands.forEach(c => {
                        const points = [];
                        if (c.x !== undefined) points.push({x: c.x, y: c.y});
                        if (c.x1 !== undefined) points.push({x: c.x1, y: c.y1});
                        if (c.x2 !== undefined) points.push({x: c.x2, y: c.y2});
                        
                        points.forEach(p => {
                            minX = Math.min(minX, el.x + p.x);
                            minY = Math.min(minY, el.y + p.y);
                            maxX = Math.max(maxX, el.x + p.x);
                            maxY = Math.max(maxY, el.y + p.y);
                        });
                    });
                    if (minX === Infinity) return { x: el.x, y: el.y, width: el.width || 0, height: el.height || 0 };
                    return {
                        x: minX,
                        y: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                } else if (el.type === 'line') {
                    return {
                        x: Math.min(el.x, el.x2),
                        y: Math.min(el.y, el.y2),
                        width: Math.abs(el.x2 - el.x),
                        height: Math.abs(el.y2 - el.y)
                    };
                } else if (el.type === 'text') {
                    // Better estimation for text bounding box
                    const width = el.width || (el.text.length * el.fontSize * 0.6);
                    const height = el.height || (el.fontSize * 1.2);
                    let x = el.x;
                    if (el.textAlign === 'center' || el.textAlign === 'middle') x -= width / 2;
                    else if (el.textAlign === 'right' || el.textAlign === 'end') x -= width;
                    return { x, y: el.y, width, height };
                } else {
                    return { x: el.x, y: el.y, width: el.width || 0, height: el.height || 0 };
                }
            };

            const groupSelection = () => {
                const idsToGroup = multiSelection.length > 0 ? multiSelection : (selection ? [selection] : []);
                if (idsToGroup.length === 0) return;
                
                const elementsToGroup = idsToGroup.map(id => findElement(id)).filter(Boolean);
                if (elementsToGroup.length === 0) return;
                
                // Calculate bounding box using proper bounds
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                elementsToGroup.forEach(el => {
                    const box = getBoundingBox(el);
                    minX = Math.min(minX, box.x);
                    minY = Math.min(minY, box.y);
                    maxX = Math.max(maxX, box.x + box.width);
                    maxY = Math.max(maxY, box.y + box.height);
                });
                
                const newGroup = {
                    id: generateId(),
                    type: 'group',
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY,
                    rotation: 0,
                    opacity: 1,
                    scale: {x: 1, y: 1},
                    locked: false,
                    animations: [],
                    children: elementsToGroup.map(el => ({
                        ...el,
                        x: el.x - minX,
                        y: el.y - minY
                    }))
                };
                
                // Remove grouped elements
                idsToGroup.forEach(id => removeElement(id));
                setElements(prev => [...prev, newGroup]);
                setSelection(newGroup.id);
                setMultiSelection([]);
            };

            const ungroupSelection = () => {
                if (!selection) return;
                const group = findElement(selection);
                if (!group || group.type !== 'group') return;
                
                const childrenToRelease = group.children.map(child => ({
                    ...child,
                    x: group.x + child.x,
                    y: group.y + child.y
                }));
                
                removeElement(selection);
                setElements(prev => [...prev, ...childrenToRelease]);
                setSelection(null);
            };

            // Keyboard Shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (selection) removeElement(selection);
                        if (multiSelection.length > 0) {
                            setElements(prev => prev.filter(el => !multiSelection.includes(el.id)));
                            setMultiSelection([]);
                        }
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            ungroupSelection();
                        } else {
                            groupSelection();
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selection, multiSelection, elements]); // Added elements dependency for safety

            const duplicateElement = (id) => {
                const original = findElement(id);
                if (!original) return;
                const newEl = { ...original, id: generateId(), x: original.x + 20, y: original.y + 20 };
                setElements(prev => [...prev, newEl]);
                setSelection(newEl.id);
            };

            // --- Animation Management ---

            const reorderAnimation = (elId, fromIndex, toIndex) => {
                const el = findElement(elId);
                if (!el || !el.animations) return;
                const newAnimations = [...el.animations];
                const [removed] = newAnimations.splice(fromIndex, 1);
                newAnimations.splice(toIndex, 0, removed);
                updateElement(elId, { animations: newAnimations });
            };

            const addAnimation = (elId) => {
                const el = findElement(elId);
                if (!el) return;
                const newAnim = {
                    id: generateId(),
                    type: 'fade',
                    duration: 1,
                    delay: 0,
                    ease: 'ease-out',
                    pathX: 100,
                    pathY: 0,
                    targetColor: el.fill || '#000000',
                    targetSize: el.fontSize || 20,
                    props: {} 
                };
                updateElement(elId, { animations: [...(el.animations || []), newAnim] });
            };

            const updateAnimation = (elId, animIndex, updates) => {
                const el = findElement(elId);
                if (!el) return;
                const newAnims = [...(el.animations || [])];
                newAnims[animIndex] = { ...newAnims[animIndex], ...updates };
                updateElement(elId, { animations: newAnims });
            };

            const removeAnimation = (elId, animIndex) => {
                const el = findElement(elId);
                if (!el) return;
                const newAnims = (el.animations || []).filter((_, i) => i !== animIndex);
                updateElement(elId, { animations: newAnims });
            };

            const autoSequenceAnimations = () => {
                let currentTime = 0;
                const newElements = elements.map(el => {
                    if (!el.animations || el.animations.length === 0) return el;
                    
                    const newAnims = el.animations.map(anim => {
                        const updatedAnim = { ...anim, delay: parseFloat(currentTime.toFixed(2)) };
                        currentTime += anim.duration;
                        return updatedAnim;
                    });
                    
                    return { ...el, animations: newAnims };
                });
                setElements(newElements);
                setActiveTab('timeline');
            };

            // --- Interaction Logic ---

            const parseSVGToElements = (svgStr, shouldGroup = true) => {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgStr, 'image/svg+xml');
                    
                    // Check for parsing errors
                    const parserError = doc.querySelector('parsererror');
                    if (parserError) {
                        console.error('SVG parsing error:', parserError.textContent);
                        return [];
                    }
                    
                    // Helper to parse path data into absolute commands
                    const parsePathData = (d) => {
                        const commands = [];
                        const tokens = d.match(/([a-zA-Z]|[-+]?\d*\.?\d+)/g);
                        if (!tokens) return [];

                        let idx = 0;
                        let cx = 0, cy = 0; // Current X, Y
                        let lastCmd = '';
                        let startX = 0, startY = 0; // For Z

                        const getVal = () => parseFloat(tokens[idx++]);

                        while (idx < tokens.length) {
                            let char = tokens[idx];
                            let cmd = char;
                            
                            if (!isNaN(parseFloat(char))) {
                                cmd = lastCmd; // Implicit repetition
                            } else {
                                idx++;
                            }

                            const isRel = cmd === cmd.toLowerCase();
                            const type = cmd.toUpperCase();

                            switch (type) {
                                case 'M': {
                                    const x = getVal() + (isRel ? cx : 0);
                                    const y = getVal() + (isRel ? cy : 0);
                                    commands.push({ type: 'M', x, y });
                                    cx = x; cy = y;
                                    startX = x; startY = y;
                                    lastCmd = isRel ? 'l' : 'L'; // M -> L implicit
                                    break;
                                }
                                case 'L': {
                                    const x = getVal() + (isRel ? cx : 0);
                                    const y = getVal() + (isRel ? cy : 0);
                                    commands.push({ type: 'L', x, y });
                                    cx = x; cy = y;
                                    lastCmd = cmd;
                                    break;
                                }
                                case 'H': {
                                    const x = getVal() + (isRel ? cx : 0);
                                    commands.push({ type: 'L', x, y: cy }); // Convert H to L
                                    cx = x;
                                    lastCmd = cmd;
                                    break;
                                }
                                case 'V': {
                                    const y = getVal() + (isRel ? cy : 0);
                                    commands.push({ type: 'L', x: cx, y }); // Convert V to L
                                    cy = y;
                                    lastCmd = cmd;
                                    break;
                                }
                                case 'C': {
                                    const x1 = getVal() + (isRel ? cx : 0);
                                    const y1 = getVal() + (isRel ? cy : 0);
                                    const x2 = getVal() + (isRel ? cx : 0);
                                    const y2 = getVal() + (isRel ? cy : 0);
                                    const x = getVal() + (isRel ? cx : 0);
                                    const y = getVal() + (isRel ? cy : 0);
                                    commands.push({ type: 'C', x1, y1, x2, y2, x, y });
                                    cx = x; cy = y;
                                    lastCmd = cmd;
                                    break;
                                }
                                case 'Q': {
                                    const x1 = getVal() + (isRel ? cx : 0);
                                    const y1 = getVal() + (isRel ? cy : 0);
                                    const x = getVal() + (isRel ? cx : 0);
                                    const y = getVal() + (isRel ? cy : 0);
                                    commands.push({ type: 'Q', x1, y1, x, y });
                                    cx = x; cy = y;
                                    lastCmd = cmd;
                                    break;
                                }
                                case 'S': { // Smooth Cubic
                                    // Reflection of last control point
                                    let x1 = cx, y1 = cy;
                                    const last = commands[commands.length-1];
                                    if (last && (last.type === 'C' || last.type === 'S')) {
                                        x1 = cx + (cx - last.x2);
                                        y1 = cy + (cy - last.y2);
                                    }
                                    const x2 = getVal() + (isRel ? cx : 0);
                                    const y2 = getVal() + (isRel ? cy : 0);
                                    const x = getVal() + (isRel ? cx : 0);
                                    const y = getVal() + (isRel ? cy : 0);
                                    commands.push({ type: 'C', x1, y1, x2, y2, x, y }); // Convert S to C
                                    cx = x; cy = y;
                                    lastCmd = cmd;
                                    break;
                                }
                                case 'Z': {
                                    commands.push({ type: 'Z' });
                                    cx = startX; cy = startY;
                                    lastCmd = cmd;
                                    break;
                                }
                                default:
                                    // Skip unsupported for now
                                    break;
                            }
                        }
                        return commands;
                    };
                    
                    // Build map of defs for <use> references
                    const defsMap = new Map();
                    Array.from(doc.querySelectorAll('[id]')).forEach(node => {
                        const id = node.getAttribute('id');
                        if (id) {
                            defsMap.set(`#${id}`, node);
                        }
                    });

                    // Helper to parse transform attribute into matrix components
                    const parseTransform = (transformStr) => {
                        const result = { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 };
                        if (!transformStr) return result;
                        
                        // Parse translate
                        const translateMatch = transformStr.match(/translate\(([^)]+)\)/);
                        if (translateMatch) {
                            const parts = translateMatch[1].split(/[\s,]+/).map(parseFloat);
                            result.x = isNaN(parts[0]) ? 0 : parts[0];
                            result.y = isNaN(parts[1]) ? 0 : parts[1];
                        }
                        
                        // Parse rotate
                        const rotateMatch = transformStr.match(/rotate\(([^)]+)\)/);
                        if (rotateMatch) {
                            const parts = rotateMatch[1].split(/[\s,]+/).map(parseFloat);
                            result.rotation = isNaN(parts[0]) ? 0 : parts[0];
                        }
                        
                        // Parse scale
                        const scaleMatch = transformStr.match(/scale\(([^)]+)\)/);
                        if (scaleMatch) {
                            const parts = scaleMatch[1].split(/[\s,]+/).map(parseFloat);
                            result.scaleX = isNaN(parts[0]) ? 1 : parts[0];
                            result.scaleY = isNaN(parts[1]) ? result.scaleX : parts[1];
                        }
                        
                        // Parse matrix (basic support for translate and scale components)
                        const matrixMatch = transformStr.match(/matrix\(([^)]+)\)/);
                        if (matrixMatch) {
                            const [a, b, c, d, e, f] = matrixMatch[1].split(/[\s,]+/).map(parseFloat);
                            result.x = e;
                            result.y = f;
                            // Extract scale and rotation from matrix
                            // This is a simplified extraction that works for common cases
                            result.scaleX = Math.sign(a) * Math.sqrt(a * a + b * b);
                            result.scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
                            if (a !== 0 || b !== 0) {
                                result.rotation = Math.atan2(b, a) * (180 / Math.PI);
                            }
                        }
                        
                        return result;
                    };

                    const getUseScale = (node, target) => {
                        let scaleX = 1;
                        let scaleY = 1;
                        const useWidth = parseFloat(node.getAttribute('width'));
                        const useHeight = parseFloat(node.getAttribute('height'));
                        const viewBox = target.getAttribute('viewBox');

                        if (viewBox) {
                            const [, , vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
                            if (vbW && !isNaN(useWidth)) scaleX = useWidth / vbW;
                            if (vbH && !isNaN(useHeight)) scaleY = useHeight / vbH;
                        }

                        if (scaleX === 1 && scaleY === 1) {
                            const targetWidth = parseFloat(target.getAttribute('width'));
                            const targetHeight = parseFloat(target.getAttribute('height'));
                            if (targetWidth && !isNaN(useWidth)) scaleX = useWidth / targetWidth;
                            if (targetHeight && !isNaN(useHeight)) scaleY = useHeight / targetHeight;
                        }

                        if (!isNaN(useWidth) && isNaN(useHeight)) scaleY = scaleX;
                        if (isNaN(useWidth) && !isNaN(useHeight)) scaleX = scaleY;
                        if (!isFinite(scaleX) || scaleX <= 0) scaleX = 1;
                        if (!isFinite(scaleY) || scaleY <= 0) scaleY = 1;
                        return { scaleX, scaleY };
                    };
                    
                    // Helper to get computed style value from element
                    const getStyleValue = (node, attr, defaultValue = null) => {
                        // Check attribute first
                        let value = node.getAttribute(attr);
                        if (value && value !== 'none' && value !== 'inherit') return value;
                        
                        // Check style attribute
                        const style = node.getAttribute('style');
                        if (style) {
                            const match = style.match(new RegExp(`${attr}\\s*:\\s*([^;]+)`));
                            if (match) return match[1].trim();
                        }
                        
                        return defaultValue;
                    };

                    // Helper to resolve fill/stroke that might reference gradients
                    const resolvePaint = (paintValue) => {
                        if (!paintValue || paintValue === 'none') return 'none';
                        // If it's a url() reference, try to get a fallback color or keep it as-is
                        if (paintValue.startsWith('url(')) {
                            // For now, return a default color since we don't have gradient support yet
                            return '#888888'; // Gray fallback for gradient references
                        }
                        return paintValue;
                    };
                    
                    // Recursive function to process nodes with transforms
                    const processNodeRecursive = (node, parentX = 0, parentY = 0, parentScale = {x: 1, y: 1}, parentRotation = 0, inheritedStyles = { fill: '#000000', stroke: 'none', fillOpacity: 1, strokeOpacity: 1, opacity: 1 }) => {
                        const elements = [];
                        
                        // Skip non-element nodes
                        if (!node.tagName) return elements;
                        const tagName = node.tagName.toLowerCase();
                        
                        // Skip defs, metadata, and other non-visual elements
                        if (['defs', 'metadata', 'title', 'desc', 'style', 'script'].includes(tagName)) {
                            return elements;
                        }
                        
                        // Check visibility
                        const display = getStyleValue(node, 'display', '');
                        const visibility = getStyleValue(node, 'visibility', '');
                        if (display === 'none' || visibility === 'hidden') {
                            return elements;
                        }
                        
                        // Parse transform for this node
                        const transformAttr = node.getAttribute('transform');
                        const localTransform = parseTransform(transformAttr);
                        
                        // Combine with parent transform
                        // Note: This is a simplified transform composition (T * R * S)
                        // For full accuracy we'd use a matrix, but this covers most SVG cases
                        const currentScale = {
                            x: parentScale.x * localTransform.scaleX,
                            y: parentScale.y * localTransform.scaleY
                        };
                        const currentRotation = parentRotation + localTransform.rotation;
                        
                        // Translation is affected by parent scale and rotation
                        // For simplicity, we'll just add them for now, but ideally we'd rotate the vector
                        const x = parentX + localTransform.x * parentScale.x;
                        const y = parentY + localTransform.y * parentScale.y;
                        
                        // Get common attributes
                        const parentOpacity = inheritedStyles.opacity ?? 1;
                        const parentFillOpacity = inheritedStyles.fillOpacity ?? 1;
                        const parentStrokeOpacity = inheritedStyles.strokeOpacity ?? 1;
                        const localFillOpacity = parseFloat(getStyleValue(node, 'fill-opacity', '1'));
                        const localStrokeOpacity = parseFloat(getStyleValue(node, 'stroke-opacity', '1'));
                        const localOpacity = parseFloat(getStyleValue(node, 'opacity', '1'));
                        const fillValue = getStyleValue(node, 'fill', inheritedStyles.fill ?? '#000000');
                        const strokeValue = getStyleValue(node, 'stroke', inheritedStyles.stroke ?? 'none');
                        const computedFillOpacity = parentFillOpacity * (isNaN(localFillOpacity) ? 1 : localFillOpacity);
                        const computedStrokeOpacity = parentStrokeOpacity * (isNaN(localStrokeOpacity) ? 1 : localStrokeOpacity);
                        const computedOpacity = parentOpacity * (isNaN(localOpacity) ? 1 : localOpacity);
                        const commonAttrs = {
                            fill: resolvePaint(fillValue),
                            fillType: 'solid',
                            fillOpacity: computedFillOpacity,
                            stroke: resolvePaint(strokeValue),
                            strokeOpacity: computedStrokeOpacity,
                            strokeWidth: parseFloat(getStyleValue(node, 'stroke-width', '1')),
                            strokeDash: parseFloat(getStyleValue(node, 'stroke-dasharray', '0')),
                            opacity: computedOpacity,
                            rotation: currentRotation,
                            scale: currentScale,
                            locked: false,
                            visible: true,
                            shadow: false,
                            animations: [],
                            gradientStops: [
                                { offset: 0, color: '#3b82f6' },
                                { offset: 100, color: '#60a5fa' }
                            ]
                        };
                        
                        if (tagName === 'use') {
                            const ref = node.getAttribute('xlink:href') || node.getAttribute('href');
                            const target = ref && defsMap.get(ref);
                            if (target) {
                                const offsetX = parseFloat(node.getAttribute('x')) || 0;
                                const offsetY = parseFloat(node.getAttribute('y')) || 0;
                                const overrideFill = resolvePaint(getStyleValue(node, 'fill', null));
                                const overrideStroke = resolvePaint(getStyleValue(node, 'stroke', null));
                                const simulated = target.cloneNode(true);
                                
                                // Apply use-specific translation and scale
                                const { scaleX, scaleY } = getUseScale(node, target);
                                const useInheritedStyles = {
                                    ...inheritedStyles,
                                    fill: fillValue,
                                    stroke: strokeValue,
                                    fillOpacity: computedFillOpacity,
                                    strokeOpacity: computedStrokeOpacity,
                                    opacity: computedOpacity
                                };
                                if (overrideFill && overrideFill !== 'none') useInheritedStyles.fill = overrideFill;
                                if (overrideStroke && overrideStroke !== 'none') useInheritedStyles.stroke = overrideStroke;
                                
                                // We pass the use's own transform and offset as parent transform to children
                                const useX = x + offsetX * currentScale.x;
                                const useY = y + offsetY * currentScale.y;
                                const useScale = { x: currentScale.x * scaleX, y: currentScale.y * scaleY };
                                
                                const resolvedElements = processNodeRecursive(simulated, useX, useY, useScale, currentRotation, useInheritedStyles);
                                resolvedElements.forEach(el => {
                                    if (overrideFill && overrideFill !== 'none') el.fill = overrideFill;
                                    if (overrideStroke && overrideStroke !== 'none') el.stroke = overrideStroke;
                                });
                                elements.push(...resolvedElements);
                            }
                            return elements;
                        }
                        // Handle <g> groups and nested <svg>
                        if (tagName === 'g' || tagName === 'symbol' || tagName === 'svg') {
                            const groupElements = [];
                            Array.from(node.children).forEach(child => {
                                const childInherited = {
                                    ...inheritedStyles,
                                    fill: fillValue,
                                    stroke: strokeValue,
                                    fillOpacity: computedFillOpacity,
                                    strokeOpacity: computedStrokeOpacity,
                                    opacity: computedOpacity
                                };
                                const childEls = processNodeRecursive(child, x, y, currentScale, currentRotation, childInherited);
                                groupElements.push(...childEls);
                            });
                            
                            if (groupElements.length > 0) {
                                // Calculate bounding box for group
                                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                groupElements.forEach(el => {
                                    const bbox = getBoundingBox(el);
                                    // Ensure we only consider elements with actual dimensions or non-zero positions
                                    minX = Math.min(minX, bbox.x);
                                    minY = Math.min(minY, bbox.y);
                                    maxX = Math.max(maxX, bbox.x + bbox.width);
                                    maxY = Math.max(maxY, bbox.y + bbox.height);
                                });
                                
                                // If we couldn't find a valid bounding box, just use the first element's position
                                if (minX === Infinity || isNaN(minX)) {
                                    minX = groupElements[0].x;
                                    minY = groupElements[0].y;
                                    maxX = minX;
                                    maxY = minY;
                                }

                                const normalizedChildren = groupElements.map(child => ({
                                    ...child,
                                    x: child.x - minX,
                                    y: child.y - minY
                                }));

                                elements.push({
                                    id: generateId(),
                                    type: 'group',
                                    x: minX,
                                    y: minY,
                                    width: Math.max(1, maxX - minX),
                                    height: Math.max(1, maxY - minY),
                                    rotation: 0, // Rotation is already baked into children
                                    opacity: commonAttrs.opacity,
                                    locked: false,
                                    visible: true,
                                    animations: [],
                                    children: normalizedChildren
                                });
                            }
                            return elements;
                        }
                        
                        // Handle <path>
                        if (node.tagName === 'path') {
                            const d = node.getAttribute('d');
                            if (d) {
                                const commands = parsePathData(d);
                                if (commands.length > 0) {
                                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                    commands.forEach(c => {
                                        if (c.x !== undefined) { minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x); }
                                        if (c.y !== undefined) { minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y); }
                                        if (c.x1 !== undefined) { minX = Math.min(minX, c.x1); maxX = Math.max(maxX, c.x1); }
                                        if (c.y1 !== undefined) { minY = Math.min(minY, c.y1); maxY = Math.max(maxY, c.y1); }
                                        if (c.x2 !== undefined) { minX = Math.min(minX, c.x2); maxX = Math.max(maxX, c.x2); }
                                        if (c.y2 !== undefined) { minY = Math.min(minY, c.y2); maxY = Math.max(maxY, c.y2); }
                                    });
                                    
                                    const normalizedCommands = commands.map(c => {
                                        const nc = { ...c };
                                        if (nc.x !== undefined) nc.x -= minX;
                                        if (nc.y !== undefined) nc.y -= minY;
                                        if (nc.x1 !== undefined) nc.x1 -= minX;
                                        if (nc.y1 !== undefined) nc.y1 -= minY;
                                        if (nc.x2 !== undefined) nc.x2 -= minX;
                                        if (nc.y2 !== undefined) nc.y2 -= minY;
                                        return nc;
                                    });

                                    elements.push({
                                        id: generateId(),
                                        type: 'path',
                                        x: x + minX * currentScale.x,
                                        y: y + minY * currentScale.y,
                                        width: (maxX - minX) * Math.abs(currentScale.x),
                                        height: (maxY - minY) * Math.abs(currentScale.y),
                                        commands: normalizedCommands,
                                        ...commonAttrs
                                    });
                                }
                            }
                        }
                        // Handle <rect>
                        else if (node.tagName === 'rect') {
                            const rectX = parseFloat(node.getAttribute('x')) || 0;
                            const rectY = parseFloat(node.getAttribute('y')) || 0;
                            const width = parseFloat(node.getAttribute('width')) || 0;
                            const height = parseFloat(node.getAttribute('height')) || 0;
                            elements.push({
                                id: generateId(),
                                type: 'rect',
                                x: x + rectX * currentScale.x,
                                y: y + rectY * currentScale.y,
                                width: width * Math.abs(currentScale.x),
                                height: height * Math.abs(currentScale.y),
                                borderRadius: parseFloat(node.getAttribute('rx') || node.getAttribute('ry') || 0),
                                ...commonAttrs
                            });
                        }
                        // Handle <circle>
                        else if (node.tagName === 'circle') {
                            const r = parseFloat(node.getAttribute('r')) || 0;
                            const cx = parseFloat(node.getAttribute('cx')) || 0;
                            const cy = parseFloat(node.getAttribute('cy')) || 0;
                            elements.push({
                                id: generateId(),
                                type: 'circle',
                                x: x + (cx - r) * currentScale.x,
                                y: y + (cy - r) * currentScale.y,
                                width: r * 2 * Math.abs(currentScale.x),
                                height: r * 2 * Math.abs(currentScale.y),
                                ...commonAttrs
                            });
                        }
                        // Handle <ellipse>
                        else if (node.tagName === 'ellipse') {
                            const rx = parseFloat(node.getAttribute('rx')) || 0;
                            const ry = parseFloat(node.getAttribute('ry')) || 0;
                            const cx = parseFloat(node.getAttribute('cx')) || 0;
                            const cy = parseFloat(node.getAttribute('cy')) || 0;
                            elements.push({
                                id: generateId(),
                                type: 'circle',
                                x: x + (cx - rx) * currentScale.x,
                                y: y + (cy - ry) * currentScale.y,
                                width: rx * 2 * Math.abs(currentScale.x),
                                height: ry * 2 * Math.abs(currentScale.y),
                                ...commonAttrs
                            });
                        }
                        // Handle <line>
                        else if (node.tagName === 'line') {
                            const x1 = parseFloat(node.getAttribute('x1')) || 0;
                            const y1 = parseFloat(node.getAttribute('y1')) || 0;
                            const x2 = parseFloat(node.getAttribute('x2')) || 0;
                            const y2 = parseFloat(node.getAttribute('y2')) || 0;
                            elements.push({
                                id: generateId(),
                                type: 'line',
                                x: x + x1 * currentScale.x,
                                y: y + y1 * currentScale.y,
                                x2: x + x2 * currentScale.x,
                                y2: y + y2 * currentScale.y,
                                width: Math.abs(x2 - x1) * Math.abs(currentScale.x),
                                height: Math.abs(y2 - y1) * Math.abs(currentScale.y),
                                markerEnd: 'none',
                                stroke: commonAttrs.stroke !== 'none' ? commonAttrs.stroke : '#ffffff',
                                strokeWidth: commonAttrs.strokeWidth || 1,
                                ...commonAttrs
                            });
                        }
                        // Handle <polygon>
                        else if (node.tagName === 'polygon') {
                            const pointsStr = node.getAttribute('points');
                            if (pointsStr) {
                                const coords = pointsStr.trim().split(/[\s,]+/).map(parseFloat);
                                const points = [];
                                for (let i = 0; i < coords.length; i += 2) {
                                    points.push({ x: coords[i], y: coords[i + 1] });
                                }
                                
                                if (points.length > 0) {
                                    const xs = points.map(p => p.x);
                                    const ys = points.map(p => p.y);
                                    const minPX = Math.min(...xs);
                                    const minPY = Math.min(...ys);
                                    
                                    elements.push({
                                        id: generateId(),
                                        type: 'polygon',
                                        x: x + minPX,
                                        y: y + minPY,
                                        width: Math.max(...xs) - minPX,
                                        height: Math.max(...ys) - minPY,
                                        points: points.map(p => ({ x: p.x - minPX, y: p.y - minPY })),
                                        ...commonAttrs
                                    });
                                }
                            }
                        }
                        // Handle <polyline> (same as polygon but not closed)
                        else if (node.tagName === 'polyline') {
                            const pointsStr = node.getAttribute('points');
                            if (pointsStr) {
                                const coords = pointsStr.trim().split(/[\s,]+/).map(parseFloat);
                                const points = [];
                                for (let i = 0; i < coords.length; i += 2) {
                                    points.push({ x: coords[i], y: coords[i + 1] });
                                }
                                
                                if (points.length > 0) {
                                    const xs = points.map(p => p.x);
                                    const ys = points.map(p => p.y);
                                    const minPX = Math.min(...xs);
                                    const minPY = Math.min(...ys);
                                    
                                    elements.push({
                                        id: generateId(),
                                        type: 'polygon',
                                        x: x + minPX,
                                        y: y + minPY,
                                        width: Math.max(...xs) - minPX,
                                        height: Math.max(...ys) - minPY,
                                        points: points.map(p => ({ x: p.x - minPX, y: p.y - minPY })),
                                        ...commonAttrs
                                    });
                                }
                            }
                        }
                        // Handle <text>
                        else if (node.tagName === 'text') {
                            const textContent = node.textContent || 'Text';
                            const fontSize = parseFloat(getStyleValue(node, 'font-size', '24'));
                            const anchor = node.getAttribute('text-anchor') || 'start';
                            const textAlign = anchor === 'middle' ? 'center' : (anchor === 'end' ? 'right' : 'left');
                            
                            // Estimate width based on character count and font size
                            const estimatedWidth = textContent.length * fontSize * 0.6;
                            const estimatedHeight = fontSize * 1.2;

                            elements.push({
                                id: generateId(),
                                type: 'text',
                                x: x + (parseFloat(node.getAttribute('x')) || 0),
                                y: y + (parseFloat(node.getAttribute('y')) || 0) - fontSize,
                                width: estimatedWidth,
                                height: estimatedHeight,
                                text: textContent,
                                fontSize: fontSize,
                                fontFamily: getStyleValue(node, 'font-family', 'Inter, sans-serif'),
                                fontWeight: getStyleValue(node, 'font-weight', 'normal'),
                                textAlign: textAlign,
                                ...commonAttrs
                            });
                        }
                        // Handle other unknown elements - log them
                        else if (node.tagName && !['svg', 'defs', 'metadata', 'title', 'desc'].includes(node.tagName.toLowerCase())) {
                            console.log('Unhandled SVG element:', node.tagName, node);
                        }
                        
                        return elements;
                    };
                    
                    // If grouping, return as an editable group with proper structure
                    if (shouldGroup) {
                        const svgElement = doc.querySelector('svg');
                        if (svgElement) {
                            const viewBox = svgElement.getAttribute('viewBox');
                            let width = parseFloat(svgElement.getAttribute('width'));
                            let height = parseFloat(svgElement.getAttribute('height'));
                            
                            // Defaults if missing
                            if (isNaN(width)) width = 200;
                            if (isNaN(height)) height = 200;
                            
                            let startX = 0;
                            let startY = 0;
                            let scaleX = 1;
                            let scaleY = 1;

                            // Parse viewBox if exists
                            if (viewBox) {
                                const [vbX, vbY, vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
                                if (vbW && vbH) {
                                    // If width/height were not specified, use viewBox dimensions
                                    if (!svgElement.hasAttribute('width')) width = vbW;
                                    if (!svgElement.hasAttribute('height')) height = vbH;
                                    
                                    scaleX = width / vbW;
                                    scaleY = height / vbH;
                                    
                                    startX = -vbX * scaleX;
                                    startY = -vbY * scaleY;
                                }
                            }
                            
                            // Parse all elements as children
                            const children = [];
                            Array.from(svgElement.children).forEach(child => {
                                const parsed = processNodeRecursive(child, startX, startY, {x: scaleX, y: scaleY});
                                children.push(...parsed);
                            });
                            
                            if (children.length === 0) return [];
                            
                            // Create a group containing all parsed elements
                            const groupId = generateId();
                            return [{
                                id: groupId,
                                type: 'group',
                                x: 0,
                                y: 0,
                                width: width,
                                height: height,
                                rotation: 0,
                                opacity: 1,
                                locked: false,
                                visible: true,
                                animations: [],
                                children: children
                            }];
                        }
                    }
                    
                    // Parse into flat list of individual elements
                    const svgElement = doc.querySelector('svg');
                    if (!svgElement) return [];
                    
                    const viewBox = svgElement.getAttribute('viewBox');
                    let width = parseFloat(svgElement.getAttribute('width'));
                    let height = parseFloat(svgElement.getAttribute('height'));
                    
                    // Defaults if missing
                    if (isNaN(width)) width = 200;
                    if (isNaN(height)) height = 200;
                    
                    let startX = 0;
                    let startY = 0;
                    let scaleX = 1;
                    let scaleY = 1;

                    // Parse viewBox if exists
                    if (viewBox) {
                        const [vbX, vbY, vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
                        if (vbW && vbH) {
                            if (!svgElement.hasAttribute('width')) width = vbW;
                            if (!svgElement.hasAttribute('height')) height = vbH;
                            
                            scaleX = width / vbW;
                            scaleY = height / vbH;
                            
                            startX = -vbX * scaleX;
                            startY = -vbY * scaleY;
                        }
                    }
                    
                    const flatElements = [];
                    Array.from(svgElement.children).forEach(child => {
                        const parsed = processNodeRecursive(child, startX, startY, {x: scaleX, y: scaleY});
                        flatElements.push(...parsed);
                    });
                    
                    return flatElements;
                } catch (e) {
                    console.error("Error parsing SVG:", e);
                    return [];
                }
            };

            const handleDrop = async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const file = e.dataTransfer.files[0];
                if (!file) return;

                if (file.type === "image/svg+xml" || file.name.toLowerCase().endsWith('.svg')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const svgContent = event.target.result;
                        try {
                            console.log('Parsing SVG, content length:', svgContent.length);
                            const els = parseSVGToElements(svgContent, true); // Group by default
                            console.log('Parsed elements:', els);
                            if (els && els.length > 0) {
                                setElements(prev => [...prev, ...els]);
                            } else {
                                console.error("No elements parsed from SVG");
                            }
                        } catch (err) {
                            console.error("SVG parsing error:", err);
                        }
                    };
                    reader.readAsText(file); // Read as text, not data URL
                } else if (file.type.startsWith("image/")) {
                    setIsProcessingImage(true);
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const imgData = event.target.result;
                        ImageTracer.imageToSVG(imgData, (svgStr) => {
                            const els = parseSVGToElements(svgStr, true); // Group by default
                            setElements(prev => [...prev, ...els]);
                            setIsProcessingImage(false);
                        }, { ltres: 0.01, qtres: 0.01, pathomit: 1, scale: 2, strokewidth: 0, viewbox: true }); 
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleDragOver = (e) => e.preventDefault();

            const findRootElement = (id) => {
                const findInTree = (list) => {
                    for (let el of list) {
                        if (el.id === id) return true;
                        if (el.children && findInTree(el.children)) return true;
                    }
                    return false;
                };
                
                for (let el of elements) {
                    if (el.id === id) return el;
                    if (el.children && findInTree(el.children)) return el;
                }
                return null;
            };

            const handlePointerDown = (e, id, action = 'move', payload = null) => {
                e.stopPropagation(); 
                if (tool !== 'select' && !id) return;
                if (e.button === 1 || tool === 'hand') return; 

                if (id) {
                    let targetId = id;
                    const rootEl = findRootElement(id);
                    
                    // Group Selection Logic
                    if (rootEl && rootEl.id !== id) {
                        if (selection === rootEl.id) {
                            // Already selected group, select child
                            targetId = id;
                        } else {
                            // Select group first
                            targetId = rootEl.id;
                        }
                    }

                    // Multi-select with Ctrl/Cmd
                    if (e.ctrlKey || e.metaKey) {
                        if (multiSelection.includes(targetId)) {
                            setMultiSelection(prev => prev.filter(i => i !== targetId));
                        } else {
                            setMultiSelection(prev => [...prev, targetId]);
                        }
                        return;
                    } else {
                        setMultiSelection([]);
                    }

                    setSelection(targetId);
                    setIsInspectorOpen(true);
                    const el = findElement(targetId);
                    if (!el || el.locked) return;
                    
                    // Path editing logic
                    if (action === 'path-point') {
                        const idx = typeof payload === 'object' ? payload.idx : payload;
                        const newSelected = new Set(e.shiftKey ? selectedPointIndices : []);
                        
                        if (e.shiftKey) {
                            if (newSelected.has(idx)) newSelected.delete(idx);
                            else newSelected.add(idx);
                        } else {
                            if (!newSelected.has(idx)) {
                                newSelected.clear();
                                newSelected.add(idx);
                            }
                        }
                        setSelectedPointIndices(newSelected);

                        setIsDragging(true);
                        setDragAction('path-point');
                        const pos = getPointerPos(e);
                        dragStartRef.current = { startMouse: pos, elState: JSON.parse(JSON.stringify(el)), payload }; 
                        return;
                    }

                    setIsDragging(true);
                    setDragAction(action);
                    const pos = getPointerPos(e);
                    dragStartRef.current = { startMouse: pos, elState: JSON.parse(JSON.stringify(el)), payload };
                } else {
                    // If in edit mode and clicking empty space, start box selection
                    if (editMode && selection) {
                        const pos = getPointerPos(e);
                        setSelectionBox({ x: pos.x, y: pos.y, w: 0, h: 0, startX: pos.x, startY: pos.y });
                        setIsDragging(true);
                        setDragAction('box-select');
                    } else {
                        setSelection(null);
                        setIsInspectorOpen(false);
                        setEditMode(false);
                        setEditTool('none');
                        setSelectedPointIndices(new Set());
                    }
                }
            };

            const handlePointerMove = (e) => {
                if (!isDragging || !selection) return;
                e.preventDefault(); 
                
                const currentMouse = getPointerPos(e);
                const { startMouse, elState, payload } = dragStartRef.current;
                let dx = currentMouse.x - startMouse.x;
                let dy = currentMouse.y - startMouse.y;
                const isShift = e.shiftKey;

                if (dragAction === 'move') {
                    // Smart guides: Calculate proposed position and check for alignments
                    let proposedX = elState.x + dx;
                    let proposedY = elState.y + dy;
                    
                    if (smartGuidesEnabled) {
                        const proposedBBox = {
                            x: proposedX,
                            y: proposedY,
                            width: elState.width || 0,
                            height: elState.height || 0
                        };
                        
                        if (elState.type === 'polygon' && elState.points) {
                            const xs = elState.points.map(p => proposedX + p.x);
                            const ys = elState.points.map(p => proposedY + p.y);
                            proposedBBox.x = Math.min(...xs);
                            proposedBBox.y = Math.min(...ys);
                            proposedBBox.width = Math.max(...xs) - Math.min(...xs);
                            proposedBBox.height = Math.max(...ys) - Math.min(...ys);
                        } else if (elState.type === 'path' && elState.commands) {
                            const coords = elState.commands.filter(c => c.x !== undefined).map(c => ({x: proposedX + c.x, y: proposedY + c.y}));
                            const xs = coords.map(p => p.x);
                            const ys = coords.map(p => p.y);
                            proposedBBox.x = Math.min(...xs);
                            proposedBBox.y = Math.min(...ys);
                            proposedBBox.width = Math.max(...xs) - Math.min(...xs);
                            proposedBBox.height = Math.max(...ys) - Math.min(...ys);
                        }
                        
                        const { guides, snapOffsets } = detectAlignments(elState, proposedBBox);
                        setActiveGuides(guides);
                        
                        // Apply snapping
                        proposedX += snapOffsets.x;
                        proposedY += snapOffsets.y;
                    } else {
                        setActiveGuides([]);
                    }
                    
                    if (elState.type === 'line') {
                        updateElement(selection, { x: proposedX, y: proposedY, x2: elState.x2 + (proposedX - elState.x), y2: elState.y2 + (proposedY - elState.y) });
                    } else {
                        updateElement(selection, { x: proposedX, y: proposedY });
                    }
                } 
                else if (dragAction === 'path-point') {
                    // Update specific point in polygon/path
                    const el = findElement(selection);
                    
                    if (el.type === 'path') {
                        const newCommands = [...el.commands];
                        
                        // Move all selected points
                        selectedPointIndices.forEach(idx => {
                            if (!newCommands[idx]) return;
                            const cmd = { ...newCommands[idx] };
                            const originalCmd = elState.commands[idx];
                            
                            // Move the point itself
                            if (cmd.x !== undefined) { 
                                cmd.x = originalCmd.x + dx; 
                                cmd.y = originalCmd.y + dy; 
                            }
                            
                            // Move incoming control point (attached to this point)
                            if (cmd.x2 !== undefined) { 
                                cmd.x2 = originalCmd.x2 + dx; 
                                cmd.y2 = originalCmd.y2 + dy; 
                            }
                            
                            // Move outgoing control point (attached to this point, but belongs to NEXT command)
                            const nextIdx = idx + 1;
                            if (newCommands[nextIdx]) {
                                const nextCmd = { ...newCommands[nextIdx] };
                                const originalNextCmd = elState.commands[nextIdx];
                                
                                // Only move if it has control points (C or Q)
                                if (nextCmd.x1 !== undefined) {
                                    nextCmd.x1 = originalNextCmd.x1 + dx;
                                    nextCmd.y1 = originalNextCmd.y1 + dy;
                                    newCommands[nextIdx] = nextCmd;
                                }
                            }

                            // Note: We do NOT move cmd.x1/y1 here because that belongs to the PREVIOUS point.
                            // Unless the previous point is also selected, in which case it will be handled by its own iteration.
                            
                            newCommands[idx] = cmd;
                        });
                        
                        updateElement(selection, { commands: newCommands });
                    }
                    else if (el.points) {
                        const newPoints = [...el.points];
                        selectedPointIndices.forEach(idx => {
                            if (!newPoints[idx]) return;
                            newPoints[idx] = { 
                                x: elState.points[idx].x + dx, 
                                y: elState.points[idx].y + dy 
                            };
                        });
                        updateElement(selection, { points: newPoints });
                    }
                }
                else if (dragAction === 'box-select') {
                    const currentMouse = getPointerPos(e);
                    const startX = selectionBox.startX;
                    const startY = selectionBox.startY;
                    setSelectionBox({
                        x: Math.min(startX, currentMouse.x),
                        y: Math.min(startY, currentMouse.y),
                        w: Math.abs(currentMouse.x - startX),
                        h: Math.abs(currentMouse.y - startY),
                        startX, startY
                    });
                }
                else if (dragAction === 'path-segment') {
                    const el = findElement(selection);
                    const idx = payload; // Index of the command ending the segment
                    const prevIdx = idx - 1;
                    
                    if (el.type === 'path') {
                        const newCommands = [...el.commands];
                        
                        // Move start point of segment (end of prev command)
                        if (prevIdx >= 0) {
                            const prevCmd = { ...newCommands[prevIdx] };
                            if (prevCmd.x !== undefined) prevCmd.x = elState.commands[prevIdx].x + dx;
                            if (prevCmd.y !== undefined) prevCmd.y = elState.commands[prevIdx].y + dy;
                            newCommands[prevIdx] = prevCmd;
                        }
                        
                        // Move end point of segment (end of current command)
                        const cmd = { ...newCommands[idx] };
                        if (cmd.x !== undefined) cmd.x = elState.commands[idx].x + dx;
                        if (cmd.y !== undefined) cmd.y = elState.commands[idx].y + dy;
                        
                        // Also move control points if it's a curve, to translate the curve rigidly
                        if (cmd.type === 'C') {
                            cmd.x1 = elState.commands[idx].x1 + dx;
                            cmd.y1 = elState.commands[idx].y1 + dy;
                            cmd.x2 = elState.commands[idx].x2 + dx;
                            cmd.y2 = elState.commands[idx].y2 + dy;
                        } else if (cmd.type === 'Q') {
                            cmd.x1 = elState.commands[idx].x1 + dx;
                            cmd.y1 = elState.commands[idx].y1 + dy;
                        }
                        
                        newCommands[idx] = cmd;
                        updateElement(selection, { commands: newCommands });
                    }
                }
                else if (dragAction === 'rotate') {
                    const el = findElement(selection);
                    const bbox = getBoundingBox(elState);
                    const centerX = bbox.x + bbox.width / 2;
                    const centerY = bbox.y + bbox.height / 2;
                    const angle = Math.atan2(currentMouse.y - centerY, currentMouse.x - centerX) * 180 / Math.PI + 90;
                    updateElement(selection, { rotation: angle });
                }
                else if (dragAction.startsWith('slice-')) {
                    const el = findElement(selection);
                    const { x, y, width, height, originalWidth, originalHeight } = elState;
                    
                    let newSlices = { ...el.slices };
                    
                    if (dragAction === 'slice-x-start') {
                        let val = ((currentMouse.x - x) / originalWidth) * 100;
                        val = Math.max(0, Math.min(val, newSlices.x.end - 5));
                        newSlices.x.start = val;
                    }
                    else if (dragAction === 'slice-x-end') {
                        let val = 100 - ((x + width - currentMouse.x) / originalWidth) * 100;
                        val = Math.max(newSlices.x.start + 5, Math.min(val, 100));
                        newSlices.x.end = val;
                    }
                    else if (dragAction === 'slice-y-start') {
                        let val = ((currentMouse.y - y) / originalHeight) * 100;
                        val = Math.max(0, Math.min(val, newSlices.y.end - 5));
                        newSlices.y.start = val;
                    }
                    else if (dragAction === 'slice-y-end') {
                        let val = 100 - ((y + height - currentMouse.y) / originalHeight) * 100;
                        val = Math.max(newSlices.y.start + 5, Math.min(val, 100));
                        newSlices.y.end = val;
                    }
                    
                    updateElement(selection, { slices: newSlices });
                }
                else if (dragAction.startsWith('crop-')) {
                    const el = findElement(selection);
                    const { x, y, width, height, originalWidth, originalHeight, crop } = elState;
                    
                    // Ensure we have valid baselines
                    const origW = originalWidth || width;
                    const origH = originalHeight || height;
                    const startCrop = crop || { x: 0, y: 0, width: 100, height: 100 };
                    
                    let newCrop = { ...startCrop };
                    let newX = x;
                    let newY = y;
                    let newW = width;
                    let newH = height;

                    // Calculate pixel changes
                    // Note: dx/dy are in canvas space. 
                    // If element is rotated, this simple logic fails. 
                    // But for now assuming axis-aligned or handling rotation later.
                    // Actually, dx/dy should be projected onto the element's local axis if rotated.
                    // But let's stick to simple axis-aligned for MVP as rotation + crop is complex.
                    
                    if (dragAction.includes('e')) {
                        newW = Math.max(1, width + dx);
                        newCrop.width = (newW / origW) * 100;
                    }
                    if (dragAction.includes('s')) {
                        newH = Math.max(1, height + dy);
                        newCrop.height = (newH / origH) * 100;
                    }
                    if (dragAction.includes('w')) {
                        const maxDx = width - 1;
                        const safeDx = Math.min(dx, maxDx);
                        newW = width - safeDx;
                        newX = x + safeDx;
                        
                        // Crop X increases (moving right into the image)
                        // The amount it increases is proportional to the width change relative to original
                        const widthChangePct = (safeDx / origW) * 100;
                        newCrop.x = startCrop.x + widthChangePct;
                        newCrop.width = startCrop.width - widthChangePct;
                    }
                    if (dragAction.includes('n')) {
                        const maxDy = height - 1;
                        const safeDy = Math.min(dy, maxDy);
                        newH = height - safeDy;
                        newY = y + safeDy;
                        
                        const heightChangePct = (safeDy / origH) * 100;
                        newCrop.y = startCrop.y + heightChangePct;
                        newCrop.height = startCrop.height - heightChangePct;
                    }

                    // Constrain crop percentages
                    newCrop.x = Math.max(0, newCrop.x);
                    newCrop.y = Math.max(0, newCrop.y);
                    newCrop.width = Math.min(100 - newCrop.x, newCrop.width);
                    newCrop.height = Math.min(100 - newCrop.y, newCrop.height);

                    updateElement(selection, { 
                        x: newX, 
                        y: newY, 
                        width: newW, 
                        height: newH, 
                        crop: newCrop 
                    });
                }
                else if (dragAction.startsWith('resize')) {
                    const el = findElement(selection);
                    const bbox = getBoundingBox(elState);
                    let { x, y, width, height, fontSize } = elState;
                    let newX = x, newY = y, newW = width, newH = height;

                    // For polygon/path, use bbox for calculations
                    if (elState.type === 'polygon' || elState.type === 'path') {
                        const bboxX = bbox.x, bboxY = bbox.y, bboxW = bbox.width, bboxH = bbox.height;
                        let newBboxX = bboxX, newBboxY = bboxY, newBboxW = bboxW, newBboxH = bboxH;

                        if (dragAction.includes('e')) newBboxW = bboxW + dx;
                        if (dragAction.includes('w')) { newBboxX = bboxX + dx; newBboxW = bboxW - dx; }
                        if (dragAction.includes('s')) newBboxH = bboxH + dy;
                        if (dragAction.includes('n')) { newBboxY = bboxY + dy; newBboxH = bboxH - dy; }

                        const scaleX = newBboxW / bboxW;
                        const scaleY = newBboxH / bboxH;

                        if (elState.type === 'polygon' && elState.points) {
                            const newPoints = elState.points.map(p => ({
                                x: (p.x - (bboxX - elState.x)) * scaleX + (newBboxX - elState.x),
                                y: (p.y - (bboxY - elState.y)) * scaleY + (newBboxY - elState.y)
                            }));
                            updateElement(selection, { points: newPoints });
                        } else if (elState.type === 'path' && elState.commands) {
                            const newCommands = elState.commands.map(cmd => {
                                const newCmd = { ...cmd };
                                if (cmd.x !== undefined) newCmd.x = (cmd.x - (bboxX - elState.x)) * scaleX + (newBboxX - elState.x);
                                if (cmd.y !== undefined) newCmd.y = (cmd.y - (bboxY - elState.y)) * scaleY + (newBboxY - elState.y);
                                if (cmd.x1 !== undefined) newCmd.x1 = (cmd.x1 - (bboxX - elState.x)) * scaleX + (newBboxX - elState.x);
                                if (cmd.y1 !== undefined) newCmd.y1 = (cmd.y1 - (bboxY - elState.y)) * scaleY + (newBboxY - elState.y);
                                if (cmd.x2 !== undefined) newCmd.x2 = (cmd.x2 - (bboxX - elState.x)) * scaleX + (newBboxX - elState.x);
                                if (cmd.y2 !== undefined) newCmd.y2 = (cmd.y2 - (bboxY - elState.y)) * scaleY + (newBboxY - elState.y);
                                return newCmd;
                            });
                            updateElement(selection, { commands: newCommands });
                        }
                        return;
                    }

                    if (dragAction.includes('e')) newW = Math.max(1, width + dx);
                    if (dragAction.includes('w')) { 
                        const maxDx = width - 1;
                        const safeDx = Math.min(dx, maxDx);
                        newX = x + safeDx; 
                        newW = width - safeDx; 
                    }
                    if (dragAction.includes('s')) newH = Math.max(1, height + dy);
                    if (dragAction.includes('n')) { 
                        const maxDy = height - 1;
                        const safeDy = Math.min(dy, maxDy);
                        newY = y + safeDy; 
                        newH = height - safeDy; 
                    }

                    if (isShift && (dragAction.includes('nw') || dragAction.includes('se') || dragAction.includes('ne') || dragAction.includes('sw'))) {
                        const ratio = width / height;
                        if (Math.abs(newW) > Math.abs(newH)) newH = newW / ratio;
                        else newW = newH * ratio;
                    }

                    let newFontSize = fontSize;
                    if (elState.type === 'text') {
                        const scaleFactor = newW / width;
                        newFontSize = fontSize * scaleFactor;
                    }
                    updateElement(selection, { x: newX, y: newY, width: newW, height: newH, fontSize: newFontSize });
                }
                else if (dragAction === 'line-end') updateElement(selection, { x2: elState.x2 + dx, y2: elState.y2 + dy });
                else if (dragAction === 'line-start') updateElement(selection, { x: elState.x + dx, y: elState.y + dy });
                else if (dragAction === 'move-target') {
                    const animIndex = payload;
                    const anim = elState.animations[animIndex];
                    updateAnimation(selection, animIndex, { 
                        pathX: anim.pathX + dx,
                        pathY: anim.pathY + dy
                    });
                }
            };

            const handlePointerUp = (e) => { 
                if (dragAction === 'box-select' && selectionBox) {
                    const el = findElement(selection);
                    const newSelected = new Set(e && e.shiftKey ? selectedPointIndices : []);
                    
                    if (el) {
                        const isPointInBox = (px, py) => {
                            const globalX = el.x + px;
                            const globalY = el.y + py;
                            return globalX >= selectionBox.x && globalX <= selectionBox.x + selectionBox.w &&
                                   globalY >= selectionBox.y && globalY <= selectionBox.y + selectionBox.h;
                        };

                        if (el.type === 'path') {
                            el.commands.forEach((cmd, i) => {
                                if (cmd.x !== undefined && isPointInBox(cmd.x, cmd.y)) newSelected.add(i);
                            });
                        } else if (el.points) {
                            el.points.forEach((p, i) => {
                                if (isPointInBox(p.x, p.y)) newSelected.add(i);
                            });
                        }
                    }
                    setSelectedPointIndices(newSelected);
                    setSelectionBox(null);
                }
                
                setIsDragging(false); 
                setDragAction(null); 
                setActiveGuides([]);
            };

            const handleTextDoubleClick = (id) => {
                const el = findElement(id);
                if (!el) return;
                const newText = prompt("Edit Text:", el.text);
                if (newText !== null) {
                    updateElement(id, { text: newText });
                }
            };

            const handleExport = () => {
                if (!svgRef.current) return;
                const clone = svgRef.current.cloneNode(true);
                clone.querySelectorAll('.ui-layer').forEach(el => el.remove());
                
                // Calculate the bounding box of all elements to set proper viewBox
                const allElements = elements.flatMap(el => el.type === 'group' ? el.children || [] : [el]).concat(elements.filter(el => el.type !== 'group'));
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                allElements.forEach(el => {
                    const bbox = getBoundingBox(el);
                    minX = Math.min(minX, bbox.x);
                    minY = Math.min(minY, bbox.y);
                    maxX = Math.max(maxX, bbox.x + bbox.width);
                    maxY = Math.max(maxY, bbox.y + bbox.height);
                });
                
                // Add padding
                const padding = 20;
                minX = (minX === Infinity ? 0 : minX) - padding;
                minY = (minY === Infinity ? 0 : minY) - padding;
                maxX = (maxX === -Infinity ? 800 : maxX) + padding;
                maxY = (maxY === -Infinity ? 600 : maxY) + padding;
                
                const width = maxX - minX;
                const height = maxY - minY;
                
                // Set normalized viewBox for export
                clone.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
                clone.setAttribute('width', width);
                clone.setAttribute('height', height);
                
                // Generate all keyframes
                const dynamicKeyframes = elements.flatMap(el => 
                    (el.animations || []).map((anim, idx) => {
                        if(anim.type === 'move') {
                            return `@keyframes move-${el.id}-${idx} { to { transform: translate(${anim.pathX}px, ${anim.pathY}px); } }`;
                        }
                        if (anim.type === 'morph') {
                            return `@keyframes morph-${el.id}-${idx} { 0% { transform: scale(1); } 50% { transform: scale(1.1) rotate(5deg); } 100% { transform: scale(1); } }`;
                        }
                        if (anim.type === 'color') {
                            const targetColor = anim.targetColor || '#ff0000';
                            const startColor = el.fill || '#000000';
                            if (el.fillType === 'gradient') {
                                return `@keyframes color-${el.id}-${idx} { from { opacity: 1; } to { opacity: 1; filter: hue-rotate(${anim.hueRotate || 180}deg) saturate(${anim.saturate || 1.5}); } }`;
                            }
                            return `@keyframes color-${el.id}-${idx} { from { fill: ${startColor}; } to { fill: ${targetColor}; } }`;
                        }
                        if (anim.type === 'textSize' && el.type === 'text') {
                            const startSize = el.fontSize || 24;
                            const targetSize = anim.targetSize || 40;
                            return `@keyframes textSize-${el.id}-${idx} { from { font-size: ${startSize}px; } to { font-size: ${targetSize}px; } }`;
                        }
                        return '';
                    })
                ).join('\n');

                // Apply animations to elements
                const applyAnimationsToExport = (el, svgEl) => {
                    if (!el.animations || el.animations.length === 0) return;
                    
                    const animationStrings = el.animations.map((anim, idx) => {
                        const preset = ANIMATION_PRESETS.find(a => a.id === anim.type);
                        if (!preset) return '';
                        
                        const timing = `${anim.duration}s ${anim.ease || 'ease-out'} ${anim.delay}s`;
                        let cssPart = preset.css.match(/animation:\s*([^;]+);/)?.[1] || '';
                        
                        cssPart = cssPart.replace('{t}', timing);
                        if (anim.type === 'move' || anim.type === 'morph' || anim.type === 'color' || anim.type === 'textSize') {
                            cssPart = cssPart.replace('{id}', el.id).replace('{idx}', idx);
                        }
                        return cssPart;
                    }).filter(Boolean);

                    if (animationStrings.length > 0) {
                        const currentStyle = svgEl.getAttribute('style') || '';
                        const animStyle = `animation: ${animationStrings.join(', ')};`;
                        
                        // Apply initial state for entrance animations
                        let initialStyles = '';
                        el.animations.forEach((anim) => {
                            const preset = ANIMATION_PRESETS.find(a => a.id === anim.type);
                            if (preset) {
                                if (preset.css.includes('opacity: 0')) {
                                    initialStyles += 'opacity: 0; ';
                                }
                                if (preset.css.includes('transform:') && !anim.type.includes('move') && !anim.type.includes('morph')) {
                                    const transformMatch = preset.css.match(/transform:\s*([^;]+);/);
                                    if (transformMatch) {
                                        initialStyles += `transform: ${transformMatch[1]}; `;
                                    }
                                }
                            }
                        });
                        
                        svgEl.setAttribute('style', currentStyle + ' ' + initialStyles + animStyle);
                    }
                };

                // Apply animations to elements in exported SVG
                elements.forEach(el => {
                    if (!el.animations || el.animations.length === 0) return;
                    
                    // Find element by data-element-id attribute
                    const svgElements = clone.querySelectorAll(`[data-element-id="${el.id}"]`);
                    
                    svgElements.forEach(svgEl => {
                        applyAnimationsToExport(el, svgEl);
                    });
                });
                
                const style = document.createElement('style');
                style.textContent = GLOBAL_STYLES + '\n' + dynamicKeyframes;
                clone.prepend(style);
                
                clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");

                let svgData = new XMLSerializer().serializeToString(clone);
                svgData = '<?xml version="1.0" standalone="no"?>\r\n' + svgData;

                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'canvas-studio-export.svg';
                a.click();
            };

            const handleSaveProject = () => {
                const projectData = {
                    version: '1.0',
                    elements,
                    view
                };
                const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'canvas-studio-project.json';
                a.click();
            };

            const handleLoadProject = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        if (projectData.elements) setElements(projectData.elements);
                        if (projectData.view) setView(projectData.view);
                    } catch (err) {
                        alert("Invalid project file");
                    }
                };
                reader.readAsText(file);
            };

            const handleWheel = (e) => {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const delta = -e.deltaY * 0.001;
                    const newZoom = Math.min(Math.max(0.1, view.zoom + delta), 10);
                    setView(v => ({ ...v, zoom: newZoom }));
                } else {
                    setView(v => ({ ...v, x: v.x + e.deltaX, y: v.y + e.deltaY }));
                }
            };

            // --- Render Logic ---
            const renderNineSlice = (el, commonProps) => {
                if (!el.slices) return null;

                const { x, y, width, height, slices, originalWidth, originalHeight } = el;
                // slices are percentages of the ORIGINAL size
                
                const x1 = (slices.x.start / 100) * originalWidth;
                const x2 = (slices.x.end / 100) * originalWidth;
                const y1 = (slices.y.start / 100) * originalHeight;
                const y2 = (slices.y.end / 100) * originalHeight;

                const wL = x1;
                const wM = x2 - x1;
                const wR = originalWidth - x2;
                const hT = y1;
                const hM = y2 - y1;
                const hB = originalHeight - y2;

                // Target dimensions
                const target_wM = Math.max(0, width - wL - wR);
                const target_hM = Math.max(0, height - hT - hB);

                // We need to render the content 9 times. 
                // To avoid duplicating the DOM too much, we can use a <symbol> or <defs> if possible, 
                // but for React rendering of arbitrary children, we might just have to render them.
                // A better way for complex content is to wrap the content in a <g> and use <use> if it was a single ID,
                // but here 'el' might be a group.
                
                // Let's assume we render the children into a <g> and then reference it? 
                // No, React re-rendering is fast enough. Let's try nested SVGs.
                
                // We need the "inner" content. 
                // We'll create a helper to render the *content* of the element without its own transform/position.
                const renderContent = () => {
                    if (el.type === 'group') return el.children.map(child => renderElement(child));
                    if (el.type === 'image') return <image href={el.href} width={originalWidth} height={originalHeight} preserveAspectRatio="none" />;
                    // For other types, we'd need to strip their x/y or ensure they are at 0,0 relative to the slice.
                    // This is complex for arbitrary shapes. 
                    // Simplification: 9-slice works best on Groups or Images where we can define a "source box".
                    return null; 
                };

                // Actually, simpler approach: 
                // If it's a path/shape, we can't easily 9-slice it without `viewBox` clipping.
                // So we MUST use nested SVGs.
                
                // We need to render the element *as if* it was at 0,0 with originalWidth/Height.
                // We can clone the element, set x=0, y=0, width=originalWidth, height=originalHeight.
                const sourceEl = { ...el, x: 0, y: 0, width: originalWidth, height: originalHeight, id: el.id + '_source', type: el.type === 'smart-slice' ? 'group' : el.type };
                // If it was a smart-slice, we treat it as a group of its children (or original content).

                // But wait, if we recurse `renderElement`, it will try to render 9-slice again if we aren't careful.
                // We need a flag to render "raw".
                
                // Let's define the 9 parts.
                const parts = [];
                const srcX = 0; const srcY = 0; // Local coords

                // Helper to create a slice
                // We use a "viewBox expansion" technique to overlap slices without stretching content.
                // This prevents seams while maintaining pixel-perfect scaling.
                const createSlice = (key, dx, dy, dw, dh, sx, sy, sw, sh) => {
                    if (sw <= 0 || sh <= 0 || dw <= 0 || dh <= 0) return null;

                    const scaleX = dw / sw;
                    const scaleY = dh / sh;
                    const overlap = 0.5; // Overlap amount in pixels

                    // Expand destination rect to overlap neighbors
                    const expandL = dx > 0 ? overlap : 0;
                    const expandR = dx + dw < width - 0.1 ? overlap : 0; // Use epsilon for float comparison
                    const expandT = dy > 0 ? overlap : 0;
                    const expandB = dy + dh < height - 0.1 ? overlap : 0;

                    const finalDx = dx - expandL;
                    const finalDy = dy - expandT;
                    const finalDw = dw + expandL + expandR;
                    const finalDh = dh + expandT + expandB;

                    // Expand source viewBox inversely to match the destination expansion
                    // This ensures we show *more* of the image instead of stretching it
                    const sourceExpandL = expandL / scaleX;
                    const sourceExpandR = expandR / scaleX;
                    const sourceExpandT = expandT / scaleY;
                    const sourceExpandB = expandB / scaleY;

                    const finalSx = sx - sourceExpandL;
                    const finalSy = sy - sourceExpandT;
                    const finalSw = sw + sourceExpandL + sourceExpandR;
                    const finalSh = sh + sourceExpandT + sourceExpandB;

                    return (
                        <svg key={key} x={finalDx} y={finalDy} width={finalDw} height={finalDh} viewBox={`${finalSx} ${finalSy} ${finalSw} ${finalSh}`} preserveAspectRatio="none" overflow="hidden">
                            <g>{renderElement(sourceEl, true)}</g> 
                        </svg>
                    );
                };

                // Row 1
                parts.push(createSlice('tl', 0, 0, wL, hT, srcX, srcY, wL, hT));
                parts.push(createSlice('tm', wL, 0, target_wM, hT, srcX + x1, srcY, wM, hT));
                parts.push(createSlice('tr', width - wR, 0, wR, hT, srcX + x2, srcY, wR, hT));

                // Row 2
                parts.push(createSlice('ml', 0, hT, wL, target_hM, srcX, srcY + y1, wL, hM));
                parts.push(createSlice('mm', wL, hT, target_wM, target_hM, srcX + x1, srcY + y1, wM, hM));
                parts.push(createSlice('mr', width - wR, hT, wR, target_hM, srcX + x2, srcY + y1, wR, hM));

                // Row 3
                parts.push(createSlice('bl', 0, height - hB, wL, hB, srcX, srcY + y2, wL, hB));
                parts.push(createSlice('bm', wL, height - hB, target_wM, hB, srcX + x1, srcY + y2, wM, hB));
                parts.push(createSlice('br', width - wR, height - hB, wR, hB, srcX + x2, srcY + y2, wR, hB));

                return (
                    <g {...commonProps}>
                        {parts}
                    </g>
                );
            };

            const renderElement = (el, isRaw = false) => {
                // --- 9-Slice Rendering ---
                if (!isRaw && el.slices) {
                    // We delegate to renderNineSlice, but we need to wrap it to apply transforms
                    // renderNineSlice returns the 9 parts in a fragment or array.
                    // We need to wrap them in a group with the element's transform.
                    
                    const style = {
                        opacity: el.opacity,
                        pointerEvents: el.locked ? 'none' : 'all',
                        cursor: tool === 'select' ? 'move' : 'default',
                        filter: el.blur ? `blur(${el.blur}px)` : 'none',
                        mixBlendMode: el.blendMode || 'normal'
                    };
                    
                    const common = {
                        fill: el.fillType === 'gradient' ? `url(#grad-${el.id})` : el.fill,
                        stroke: el.stroke,
                        strokeWidth: el.strokeWidth,
                        strokeDasharray: el.strokeDash,
                        strokeOpacity: el.strokeOpacity,
                        fillOpacity: el.fillOpacity,
                        className: "canvas-obj"
                    };

                    const nineSliceContent = renderNineSlice(el, common);
                    if (nineSliceContent) {
                        const transformParts = [`translate(${el.x},${el.y})`];
                        if (el.rotation) transformParts.push(`rotate(${el.rotation} ${el.width/2} ${el.height/2})`);
                        
                        return (
                            <g key={el.id} data-element-id={el.id} transform={transformParts.join(' ')} style={style} 
                               onMouseDown={(e) => handlePointerDown(e, el.id)}
                               onTouchStart={(e) => handlePointerDown(e, el.id)}>
                                {nineSliceContent}
                            </g>
                        );
                    }
                }

                // --- Crop Rendering ---
                // We allow crop to run even if isRaw is true, because 9-slice needs the cropped source.
                // But we must ensure we don't apply outer transforms if isRaw is true.
                if (el.crop) {
                    const style = {
                        opacity: el.opacity,
                        pointerEvents: el.locked ? 'none' : 'all',
                        cursor: tool === 'select' ? 'move' : 'default',
                        filter: el.blur ? `blur(${el.blur}px)` : 'none',
                        mixBlendMode: el.blendMode || 'normal'
                    };

                    const origW = el.originalWidth || el.width;
                    const origH = el.originalHeight || el.height;
                    
                    const vbX = (el.crop.x / 100) * origW;
                    const vbY = (el.crop.y / 100) * origH;
                    const vbW = (el.crop.width / 100) * origW;
                    const vbH = (el.crop.height / 100) * origH;
                    
                    const transformParts = isRaw ? [] : [`translate(${el.x},${el.y})`];
                    if (!isRaw && el.rotation) transformParts.push(`rotate(${el.rotation} ${el.width/2} ${el.height/2})`);
                    if (!isRaw && (el.scale?.x || el.scale?.y)) transformParts.push(`scale(${el.scale?.x || 1},${el.scale?.y || 1})`);

                    // Clone element to render inside without transforms
                    const innerEl = { ...el, x: 0, y: 0, rotation: 0, scale: {x:1, y:1}, crop: null, slices: null, id: el.id + '-inner' };
                    
                    return (
                        <g key={el.id} data-element-id={el.id} transform={transformParts.join(' ')} style={style}
                           onMouseDown={(e) => handlePointerDown(e, el.id)}
                           onTouchStart={(e) => handlePointerDown(e, el.id)}>
                            <svg width={el.width} height={el.height} viewBox={`${vbX} ${vbY} ${vbW} ${vbH}`} preserveAspectRatio="none">
                                {renderElement(innerEl, true)}
                            </svg>
                        </g>
                    );
                }

                const isSelected = !isRaw && selection === el.id;
                
                let style = { 
                    opacity: el.opacity, 
                    pointerEvents: isRaw ? 'none' : 'all',
                    cursor: tool === 'select' ? 'move' : 'default',
                    touchAction: 'none' 
                };

                if (isPlaying && el.animations && el.animations.length > 0) {
                    const animationStrings = el.animations.map((anim, idx) => {
                        const preset = ANIMATION_PRESETS.find(a => a.id === anim.type);
                        if (!preset) return '';
                        
                        const timing = `${anim.duration}s ${anim.ease || 'ease'} ${anim.delay}s`;
                        let cssPart = preset.css.match(/animation:\s*([^;]+);/)?.[1] || '';
                        
                        cssPart = cssPart.replace('{t}', timing);
                        if (anim.type === 'move' || anim.type === 'morph' || anim.type === 'color' || anim.type === 'textSize') {
                            cssPart = cssPart.replace('{id}', el.id).replace('{idx}', idx);
                        }
                        return cssPart;
                    }).filter(Boolean);

                    if (animationStrings.length > 0) {
                        style.animation = animationStrings.join(', ');
                    }
                    
                    // Apply animation-specific inline styles
                    el.animations.forEach((anim, idx) => {
                        const preset = ANIMATION_PRESETS.find(a => a.id === anim.type);
                        if (preset && preset.css.includes('opacity: 0')) {
                            style.opacity = 0; // Start invisible for entrance animations
                        }
                        if (preset && preset.css.includes('transform:')) {
                            const transformMatch = preset.css.match(/transform:\s*([^;]+);/);
                            if (transformMatch && !anim.type.includes('move') && !anim.type.includes('morph')) {
                                style.transform = transformMatch[1]; // Apply initial transform
                            }
                        }
                    });
                }

                const fill = el.fillType === 'gradient' ? `url(#grad-${el.id})` : el.fill;
                const filter = el.shadow ? 'url(#shadow)' : '';
                
                const eventHandlers = isRaw ? {} : {
                    onMouseDown: (e) => handlePointerDown(e, el.id),
                    onTouchStart: (e) => handlePointerDown(e, el.id)
                };

                const common = {
                    fill,
                    filter,
                    stroke: el.stroke,
                    strokeWidth: el.strokeWidth,
                    strokeDasharray: el.strokeDash,
                    fillOpacity: el.fillOpacity,
                    strokeOpacity: el.strokeOpacity,
                    ...eventHandlers,
                    style,
                    className: "canvas-obj",
                    'data-element-id': el.id
                };

                // Group Rendering
                if (el.type === 'group') {
                    return (
                        <g key={el.id} style={style} data-element-id={el.id} transform={isRaw ? '' : `translate(${el.x},${el.y}) rotate(${el.rotation || 0} ${el.width/2} ${el.height/2}) scale(${el.scale?.x || 1}, ${el.scale?.y || 1})`} {...eventHandlers}>
                            {el.children && el.children.map(child => renderElement(child))}
                        </g>
                    );
                }

                // SVG Template Rendering
                if (el.type === 'svg-template') {
                    return (
                        <g key={el.id} style={style} data-element-id={el.id} {...eventHandlers}>
                            <g transform={isRaw ? '' : `translate(${el.x},${el.y}) scale(${el.width/100},${el.height/100})`} dangerouslySetInnerHTML={{__html: el.templateSvg}} />
                        </g>
                    );
                }

                // Path Rendering (Editable)
                if (el.type === 'path') {
                    const d = el.commands.map(c => {
                        if (c.type === 'M') return `M ${c.x} ${c.y}`;
                        if (c.type === 'L') return `L ${c.x} ${c.y}`;
                        if (c.type === 'C') return `C ${c.x1} ${c.y1}, ${c.x2} ${c.y2}, ${c.x} ${c.y}`;
                        if (c.type === 'Q') return `Q ${c.x1} ${c.y1}, ${c.x} ${c.y}`;
                        if (c.type === 'Z') return 'Z';
                        return '';
                    }).join(' ');
                    const scaleX = el.scale?.x || 1;
                    const scaleY = el.scale?.y || 1;
                    const transformParts = isRaw ? [] : [`translate(${el.x},${el.y})`];
                    if (!isRaw && el.rotation) transformParts.push(`rotate(${el.rotation} ${el.width/2} ${el.height/2})`);
                    if (!isRaw && (scaleX !== 1 || scaleY !== 1)) transformParts.push(`scale(${scaleX},${scaleY})`);
                    
                    return (
                        <g key={el.id} data-element-id={el.id} transform={transformParts.join(' ')}>
                            <path d={d} {...common} />
                        </g>
                    );
                }

                // Polygon Rendering (Editable)
                if (el.type === 'polygon') {
                    const pointsStr = el.points.map(p => `${p.x},${p.y}`).join(' ');
                    const scaleX = el.scale?.x || 1;
                    const scaleY = el.scale?.y || 1;
                    const transformParts = isRaw ? [] : [`translate(${el.x},${el.y})`];
                    if (!isRaw && el.rotation) transformParts.push(`rotate(${el.rotation} ${el.width/2} ${el.height/2})`);
                    if (!isRaw && (scaleX !== 1 || scaleY !== 1)) transformParts.push(`scale(${scaleX},${scaleY})`);
                    return (
                        <g key={el.id} data-element-id={el.id} transform={transformParts.join(' ')}>
                            <polygon points={pointsStr} {...common} />
                        </g>
                    );
                }

                if (el.type === 'line') {
                    return (
                        <g key={el.id} className="canvas-obj" style={style} data-element-id={el.id}>
                            <line x1={el.x} y1={el.y} x2={el.x2} y2={el.y2} stroke={el.stroke} strokeWidth={el.strokeWidth} strokeDasharray={el.strokeDash} strokeOpacity={el.strokeOpacity} markerEnd={el.markerEnd === 'arrow' ? 'url(#arrow)' : ''} {...eventHandlers} />
                            <line x1={el.x} y1={el.y} x2={el.x2} y2={el.y2} stroke="transparent" strokeWidth="20" {...eventHandlers} />
                        </g>
                    );
                }

                if (el.type === 'image') {
                    return <image key={el.id} href={el.href} x={isRaw ? 0 : el.x} y={isRaw ? 0 : el.y} width={el.width} height={el.height} preserveAspectRatio="none" {...common} />;
                }
                if (el.type === 'text') {
                    const lines = el.text.split('\n');
                    const lineHeight = el.fontSize * 1.2;
                    const scaleX = el.scale?.x || 1;
                    const scaleY = el.scale?.y || 1;
                    const transformParts = isRaw ? [] : [`translate(${el.x},${el.y})`];
                    if (!isRaw && el.rotation) transformParts.push(`rotate(${el.rotation})`);
                    if (!isRaw && (scaleX !== 1 || scaleY !== 1)) transformParts.push(`scale(${scaleX},${scaleY})`);
                    return (
                        <g key={el.id} data-element-id={el.id} transform={transformParts.join(' ')}>
                            <text x={0} y={0} fontSize={el.fontSize} fontFamily={el.fontFamily} fontWeight={el.fontWeight} textAnchor={el.textAlign} dy="0.8em" {...common} style={{...style, userSelect: 'none'}} onDoubleClick={(e) => { e.stopPropagation(); handleTextDoubleClick(el.id); }}>
                                {lines.map((line, i) => (
                                    <tspan key={i} x={0} dy={i === 0 ? 0 : lineHeight}>{line}</tspan>
                                ))}
                            </text>
                        </g>
                    );
                }
                if (el.type === 'circle') {
                    const scaleX = el.scale?.x || 1;
                    const scaleY = el.scale?.y || 1;
                    const transformParts = isRaw ? [] : [`translate(${el.x},${el.y})`];
                    if (!isRaw && el.rotation) transformParts.push(`rotate(${el.rotation} ${el.width/2} ${el.height/2})`);
                    if (!isRaw && (scaleX !== 1 || scaleY !== 1)) transformParts.push(`scale(${scaleX},${scaleY})`);
                    return (
                        <g key={el.id} style={style} data-element-id={el.id} transform={transformParts.join(' ')} {...eventHandlers}>
                            <circle cx={el.width/2} cy={el.height/2} r={el.width/2} fill={fill} filter={filter} stroke={el.stroke} strokeWidth={el.strokeWidth} strokeDasharray={el.strokeDash} fillOpacity={el.fillOpacity} strokeOpacity={el.strokeOpacity} className="canvas-obj" />
                        </g>
                    );
                }
                return (
                    <g key={el.id} style={style} data-element-id={el.id} transform={isRaw ? '' : `translate(${el.x},${el.y}) rotate(${el.rotation || 0} ${el.width/2} ${el.height/2}) scale(${el.scale?.x || 1},${el.scale?.y || 1})`} {...eventHandlers}>
                        <rect x={0} y={0} width={el.width} height={el.height} rx={el.borderRadius} fill={fill} filter={filter} stroke={el.stroke} strokeWidth={el.strokeWidth} strokeDasharray={el.strokeDash} fillOpacity={el.fillOpacity} strokeOpacity={el.strokeOpacity} className="canvas-obj" />
                    </g>
                );
            };

            const renderTransformGizmo = () => {
                if (!selection || isPlaying) return null;
                const el = findElement(selection);
                if (!el || el.locked) return null;

                const handleSize = 10 / view.zoom; 
                const borderSize = 2 / view.zoom;

                // --- Smart Slice Editor ---
                if (editTool === 'slice' && el.slices) {
                    const { x, y, width, height, slices, originalWidth, originalHeight } = el;
                    
                    // Calculate visual positions of the slice lines
                    // slices are percentages of ORIGINAL size.
                    // But the element is currently rendered at 'width'/'height'.
                    
                    // In 9-slice:
                    // Left cap width = (slices.x.start / 100) * originalWidth
                    // Right cap width = (100 - slices.x.end) / 100 * originalWidth
                    // These widths are preserved.
                    
                    // So visually:
                    // Left line x = Left cap width
                    // Right line x = width - Right cap width
                    
                    const leftCapW = (slices.x.start / 100) * originalWidth;
                    const rightCapW = ((100 - slices.x.end) / 100) * originalWidth;
                    const topCapH = (slices.y.start / 100) * originalHeight;
                    const bottomCapH = ((100 - slices.y.end) / 100) * originalHeight;

                    const lineX1 = leftCapW;
                    const lineX2 = width - rightCapW;
                    const lineY1 = topCapH;
                    const lineY2 = height - bottomCapH;

                    // We use the same transform as the element to ensure rotation/scale alignment
                    const transform = `translate(${el.x},${el.y}) rotate(${el.rotation || 0} ${el.width/2} ${el.height/2}) scale(${el.scale?.x || 1}, ${el.scale?.y || 1})`;

                    return (
                        <g className="ui-layer" transform={transform}>
                            {/* Outline */}
                            <rect x={0} y={0} width={width} height={height} fill="none" stroke="#ec4899" strokeWidth={1} strokeDasharray="4 4" pointerEvents="none" />
                            
                            {/* Vertical Lines */}
                            <line x1={lineX1} y1={0} x2={lineX1} y2={height} stroke="#f43f5e" strokeWidth={2/view.zoom} className="cursor-col-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'slice-x-start')} />
                            <line x1={lineX2} y1={0} x2={lineX2} y2={height} stroke="#f43f5e" strokeWidth={2/view.zoom} className="cursor-col-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'slice-x-end')} />
                            
                            {/* Horizontal Lines */}
                            <line x1={0} y1={lineY1} x2={width} y2={lineY1} stroke="#f43f5e" strokeWidth={2/view.zoom} className="cursor-row-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'slice-y-start')} />
                            <line x1={0} y1={lineY2} x2={width} y2={lineY2} stroke="#f43f5e" strokeWidth={2/view.zoom} className="cursor-row-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'slice-y-end')} />
                            
                            {/* Resize Handles (Standard) */}
                            <rect x={width - handleSize} y={height - handleSize} width={handleSize*2} height={handleSize*2} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-nwse-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'resize-se')} />
                        </g>
                    );
                }

                // Path Editing Gizmos
                if (editTool === 'points' && el.type === 'path') {
                    return (
                        <g className="ui-layer">
                            {/* Selection Box */}
                            {selectionBox && (
                                <rect 
                                    x={selectionBox.x} 
                                    y={selectionBox.y} 
                                    width={selectionBox.w} 
                                    height={selectionBox.h} 
                                    fill="rgba(0, 160, 255, 0.2)" 
                                    stroke="#00a0ff" 
                                    strokeWidth={1 / view.zoom} 
                                    style={{ pointerEvents: 'none' }}
                                />
                            )}

                            {/* Segment Handles (Lines between points) */}
                            {el.commands.map((cmd, i) => {
                                if (i === 0) return null; // Skip first command (usually M)
                                const prevCmd = el.commands[i-1];
                                if (!prevCmd || prevCmd.x === undefined || prevCmd.y === undefined) return null;
                                if (cmd.x === undefined || cmd.y === undefined) return null;

                                // Determine segment type
                                let pathD = '';
                                if (cmd.type === 'L' || cmd.type === 'H' || cmd.type === 'V') {
                                    pathD = `M ${el.x + prevCmd.x} ${el.y + prevCmd.y} L ${el.x + cmd.x} ${el.y + cmd.y}`;
                                } else if (cmd.type === 'C') {
                                    pathD = `M ${el.x + prevCmd.x} ${el.y + prevCmd.y} C ${el.x + cmd.x1} ${el.y + cmd.y1}, ${el.x + cmd.x2} ${el.y + cmd.y2}, ${el.x + cmd.x} ${el.y + cmd.y}`;
                                } else if (cmd.type === 'Q') {
                                    pathD = `M ${el.x + prevCmd.x} ${el.y + prevCmd.y} Q ${el.x + cmd.x1} ${el.y + cmd.y1}, ${el.x + cmd.x} ${el.y + cmd.y}`;
                                } else {
                                    // Fallback for other types, just straight line
                                    pathD = `M ${el.x + prevCmd.x} ${el.y + prevCmd.y} L ${el.x + cmd.x} ${el.y + cmd.y}`;
                                }

                                return (
                                    <path 
                                        key={`seg-${i}`} 
                                        d={pathD} 
                                        stroke="transparent" 
                                        strokeWidth={10 / view.zoom} 
                                        fill="none" 
                                        className="cursor-move hover:stroke-purple-500/30" 
                                        onMouseDown={(e) => handlePointerDown(e, el.id, 'path-segment', i)}
                                        onTouchStart={(e) => handlePointerDown(e, el.id, 'path-segment', i)}
                                    />
                                );
                            })}

                            {el.commands.map((cmd, i) => {
                                const handles = [];
                                const isSelected = selectedPointIndices.has(i);
                                // Main point
                                if (cmd.x !== undefined && cmd.y !== undefined) {
                                    handles.push(
                                        <circle key={`p-${i}`} cx={el.x + cmd.x} cy={el.y + cmd.y} r={handleSize * 0.8} 
                                            fill={isSelected ? "#00a0ff" : "#fff"} 
                                            stroke="#ec4899" strokeWidth={borderSize} className="cursor-crosshair"
                                            onMouseDown={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'main' })}
                                            onTouchStart={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'main' })}
                                        />
                                    );
                                }
                                // Control points for C
                                if (cmd.type === 'C') {
                                    handles.push(
                                        <line key={`l1-${i}`} x1={el.x + cmd.x1} y1={el.y + cmd.y1} x2={el.commands[i-1]?.x !== undefined ? el.x + el.commands[i-1].x : el.x + cmd.x1} y2={el.commands[i-1]?.y !== undefined ? el.y + el.commands[i-1].y : el.y + cmd.y1} stroke="#ec4899" strokeWidth={1} strokeDasharray="2,2" />,
                                        <circle key={`c1-${i}`} cx={el.x + cmd.x1} cy={el.y + cmd.y1} r={handleSize * 0.6} fill="#ec4899" className="cursor-crosshair"
                                            onMouseDown={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'c1' })}
                                            onTouchStart={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'c1' })}
                                        />,
                                        <line key={`l2-${i}`} x1={el.x + cmd.x2} y1={el.y + cmd.y2} x2={el.x + cmd.x} y2={el.y + cmd.y} stroke="#ec4899" strokeWidth={1} strokeDasharray="2,2" />,
                                        <circle key={`c2-${i}`} cx={el.x + cmd.x2} cy={el.y + cmd.y2} r={handleSize * 0.6} fill="#ec4899" className="cursor-crosshair"
                                            onMouseDown={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'c2' })}
                                            onTouchStart={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'c2' })}
                                        />
                                    );
                                }
                                // Control points for Q
                                if (cmd.type === 'Q') {
                                    handles.push(
                                        <line key={`lq-${i}`} x1={el.x + cmd.x1} y1={el.y + cmd.y1} x2={el.x + cmd.x} y2={el.y + cmd.y} stroke="#ec4899" strokeWidth={1} strokeDasharray="2,2" />,
                                        <circle key={`cq-${i}`} cx={el.x + cmd.x1} cy={el.y + cmd.y1} r={handleSize * 0.6} fill="#ec4899" className="cursor-crosshair"
                                            onMouseDown={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'c1' })}
                                            onTouchStart={(e) => handlePointerDown(e, el.id, 'path-point', { idx: i, type: 'c1' })}
                                        />
                                    );
                                }
                                return handles;
                            })}
                        </g>
                    );
                }

                // Path Editing Gizmos (Polygon)
                if (editTool === 'points' && el.points) {
                    return (
                        <g className="ui-layer">
                            {/* Selection Box */}
                            {selectionBox && (
                                <rect 
                                    x={selectionBox.x} 
                                    y={selectionBox.y} 
                                    width={selectionBox.w} 
                                    height={selectionBox.h} 
                                    fill="rgba(0, 160, 255, 0.2)" 
                                    stroke="#00a0ff" 
                                    strokeWidth={1 / view.zoom} 
                                    style={{ pointerEvents: 'none' }}
                                />
                            )}
                            {el.points.map((pt, i) => {
                                const isSelected = selectedPointIndices.has(i);
                                return (
                                    <circle 
                                        key={i} 
                                        cx={el.x + pt.x} 
                                        cy={el.y + pt.y} 
                                        r={handleSize * 0.8} 
                                        fill={isSelected ? "#00a0ff" : "#fff"} 
                                        stroke="#ec4899" 
                                        strokeWidth={borderSize} 
                                        className="cursor-crosshair"
                                        onMouseDown={(e) => handlePointerDown(e, el.id, 'path-point', i)}
                                        onTouchStart={(e) => handlePointerDown(e, el.id, 'path-point', i)}
                                    />
                                );
                            })}
                        </g>
                    );
                }

                const pathGizmos = (el.animations || []).map((anim, idx) => {
                    if (anim.type !== 'move') return null;
                    return (
                        <g className="ui-layer" key={idx}>
                            <line x1={el.x + el.width/2} y1={el.y + el.height/2} x2={el.x + el.width/2 + anim.pathX} y2={el.y + el.height/2 + anim.pathY} stroke="#10b981" strokeWidth={2/view.zoom} strokeDasharray={4/view.zoom} />
                            <circle cx={el.x + el.width/2 + anim.pathX} cy={el.y + el.height/2 + anim.pathY} r={handleSize * 1.2} fill="#10b981" stroke="white" strokeWidth={borderSize} className="cursor-move" onMouseDown={(e) => handlePointerDown(e, el.id, 'move-target', idx)} onTouchStart={(e) => handlePointerDown(e, el.id, 'move-target', idx)} />
                            <text x={el.x + el.width/2 + anim.pathX + 15} y={el.y + el.height/2 + anim.pathY + 5} fontSize={12} fill="#10b981" fontWeight="bold" pointerEvents="none">#{idx+1}</text>
                        </g>
                    );
                });

                const handlers = (action) => ({
                    onMouseDown: (e) => handlePointerDown(e, el.id, action),
                    onTouchStart: (e) => handlePointerDown(e, el.id, action)
                });

                if (el.type === 'line') {
                    return (
                        <g className="ui-layer">
                            {pathGizmos}
                            <circle cx={el.x} cy={el.y} r={handleSize} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-move" {...handlers('line-start')} />
                            <circle cx={el.x2} cy={el.y2} r={handleSize} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-move" {...handlers('line-end')} />
                        </g>
                    );
                }
                // Get proper bounding box for all element types
                const bbox = getBoundingBox(el);
                
                // Calculate local bounding box (relative to element's origin)
                // This allows the gizmo to rotate/scale with the element
                const localBBox = {
                    x: bbox.x - el.x,
                    y: bbox.y - el.y,
                    width: bbox.width,
                    height: bbox.height
                };

                const transform = `translate(${el.x},${el.y}) rotate(${el.rotation || 0} ${el.width/2} ${el.height/2}) scale(${el.scale?.x || 1}, ${el.scale?.y || 1})`;

                // --- Crop Editor ---
                if (editTool === 'crop') {
                    // In crop mode, we show the full original content (ghosted) if possible, 
                    // but for now let's just show the crop box handles on top of the current element.
                    // The crop box represents the visible area.
                    // Actually, to crop "outwards", we need to see what's outside.
                    // This is complex without a "source" image reference.
                    // Let's assume we are cropping *into* the current view.
                    
                    return (
                        <g className="ui-layer" transform={transform}>
                            {/* Crop Box Outline */}
                            <rect x={0} y={0} width={el.width} height={el.height} fill="none" stroke="#fff" strokeWidth={1} strokeDasharray="4 4" />
                            <rect x={0} y={0} width={el.width} height={el.height} fill="none" stroke="#000" strokeWidth={1} strokeDasharray="4 4" strokeDashoffset={4} />
                            
                            {/* Darken area outside? No, we can't easily draw outside in this transform group without being clipped maybe? */}
                            
                            {/* Crop Handles */}
                            {/* Corners */}
                            <rect x={-handleSize} y={-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-nw-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-nw')} />
                            <rect x={el.width-handleSize} y={-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-ne-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-ne')} />
                            <rect x={el.width-handleSize} y={el.height-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-se-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-se')} />
                            <rect x={-handleSize} y={el.height-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-sw-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-sw')} />
                            
                            {/* Edges */}
                            <rect x={el.width/2-handleSize} y={-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-n-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-n')} />
                            <rect x={el.width/2-handleSize} y={el.height-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-s-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-s')} />
                            <rect x={-handleSize} y={el.height/2-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-w-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-w')} />
                            <rect x={el.width-handleSize} y={el.height/2-handleSize} width={handleSize*2} height={handleSize*2} fill="#fff" stroke="#000" className="cursor-e-resize" onMouseDown={(e) => handlePointerDown(e, el.id, 'crop-e')} />
                        </g>
                    );
                }

                return (
                    <g className="ui-layer" transform={transform}>
                        {pathGizmos}
                        <rect x={localBBox.x} y={localBBox.y} width={localBBox.width} height={localBBox.height} fill="none" stroke="#2563eb" strokeWidth={borderSize / Math.max(Math.abs(el.scale?.x || 1), Math.abs(el.scale?.y || 1))} strokeDasharray={4/view.zoom} pointerEvents="none"/>
                        
                        {/* Resize Handles - Positioned relative to localBBox */}
                        <rect x={localBBox.x - handleSize} y={localBBox.y - handleSize} width={handleSize*2} height={handleSize*2} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-nwse-resize" {...handlers('resize-nw')} />
                        <rect x={localBBox.x + localBBox.width - handleSize} y={localBBox.y - handleSize} width={handleSize*2} height={handleSize*2} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-nesw-resize" {...handlers('resize-ne')} />
                        <rect x={localBBox.x - handleSize} y={localBBox.y + localBBox.height - handleSize} width={handleSize*2} height={handleSize*2} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-nesw-resize" {...handlers('resize-sw')} />
                        <rect x={localBBox.x + localBBox.width - handleSize} y={localBBox.y + localBBox.height - handleSize} width={handleSize*2} height={handleSize*2} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-nwse-resize" {...handlers('resize-se')} />
                        
                        {/* Multi-selection overlays - Need to be inverse transformed or handled differently. 
                            For now, we skip multi-selection overlay inside the transformed group to avoid complexity, 
                            or we'd need to render them outside. Let's render them outside. */}
                        
                        {/* Rotation handle */}
                        <line x1={localBBox.x + localBBox.width/2} y1={localBBox.y} x2={localBBox.x + localBBox.width/2} y2={localBBox.y - 20/view.zoom} stroke="#2563eb" strokeWidth={borderSize} strokeDasharray={2/view.zoom} pointerEvents="none"/>
                        <circle cx={localBBox.x + localBBox.width/2} cy={localBBox.y - 20/view.zoom} r={handleSize} fill="white" stroke="#2563eb" strokeWidth={borderSize} className="cursor-grab" {...handlers('rotate')} />
                    </g>
                );
            };

            const selectedEl = findElement(selection);
            const categories = [...new Set(ANIMATION_PRESETS.map(a => a.category))];

            return (
                <div className="flex h-screen bg-slate-900 text-slate-800 font-sans overflow-hidden flex-col md:flex-row">
                    
                    {/* Loading Overlay */}
                    {isProcessingImage && (
                        <div className="fixed inset-0 z-[60] bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center">
                            <div className="w-16 h-16 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mb-4"></div>
                            <h3 className="text-xl font-bold text-white">Vectorizing Image...</h3>
                            <p className="text-slate-400 text-sm">This might take a moment</p>
                        </div>
                    )}

                    {/* Intro */}
                    {showIntro && (
                        <div className="fixed inset-0 z-50 bg-black/70 backdrop-blur-lg flex items-center justify-center p-4">
                            <div className="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 rounded-2xl shadow-2xl max-w-4xl w-full overflow-hidden border border-purple-500/30">
                                <div className="grid md:grid-cols-3 gap-6 p-8">
                                    <div className="md:col-span-1 flex flex-col justify-center">
                                        <div className="w-16 h-16 bg-gradient-to-br from-purple-500 to-pink-500 rounded-2xl flex items-center justify-center mb-6 shadow-lg shadow-purple-500/50"><Sparkles size={32} className="text-white" /></div>
                                        <h2 className="text-3xl font-bold mb-2 bg-gradient-to-r from-purple-300 to-pink-300 bg-clip-text text-transparent">Studio Pro</h2>
                                        <p className="text-purple-200 text-sm leading-relaxed">Advanced SVG Design & Animation Engine</p>
                                    </div>
                                    <div className="md:col-span-2 space-y-4">
                                        <div className="grid grid-cols-2 gap-4">
                                            <div className="bg-gradient-to-br from-blue-500/20 to-cyan-500/20 p-4 rounded-lg border border-blue-400/30">
                                                <div className="text-blue-300 text-xs font-bold mb-1"> Templates</div>
                                                <p className="text-blue-200 text-xs">20+ SVG templates ready to use</p>
                                            </div>
                                            <div className="bg-gradient-to-br from-purple-500/20 to-pink-500/20 p-4 rounded-lg border border-purple-400/30">
                                                <div className="text-purple-300 text-xs font-bold mb-1"> Morphing</div>
                                                <p className="text-purple-200 text-xs">PowerPoint-like shape morphs</p>
                                            </div>
                                            <div className="bg-gradient-to-br from-green-500/20 to-emerald-500/20 p-4 rounded-lg border border-green-400/30">
                                                <div className="text-green-300 text-xs font-bold mb-1"> 15+ Animations</div>
                                                <p className="text-green-200 text-xs">Professional motion effects</p>
                                            </div>
                                            <div className="bg-gradient-to-br from-yellow-500/20 to-orange-500/20 p-4 rounded-lg border border-yellow-400/30">
                                                <div className="text-yellow-300 text-xs font-bold mb-1"> Smart Tools</div>
                                                <p className="text-yellow-200 text-xs">Intuitive editing & sequencing</p>
                                            </div>
                                        </div>
                                        <div className="flex gap-3 pt-2">
                                            <button onClick={() => setShowIntro(false)} className="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 rounded-lg font-semibold hover:from-purple-600 hover:to-pink-600 transition-all flex items-center justify-center gap-2 shadow-lg shadow-purple-500/50">Start Blank <ArrowRight size={16}/></button>
                                            <button onClick={() => { setShowIntro(false); setShowTemplates(true); }} className="flex-1 bg-white/10 text-white py-3 rounded-lg font-semibold hover:bg-white/20 transition-all border border-white/20">Browse Templates</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Templates Modal */}
                    {showTemplates && (
                        <div className="fixed inset-0 z-50 bg-black/70 backdrop-blur-lg flex items-center justify-center p-4">
                            <div className="bg-gradient-to-br from-slate-900 to-slate-800 rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-y-auto custom-scrollbar border border-purple-500/30">
                                <div className="sticky top-0 bg-slate-900 border-b border-purple-500/30 p-6 flex justify-between items-center">
                                    <h2 className="text-2xl font-bold bg-gradient-to-r from-purple-300 to-pink-300 bg-clip-text text-transparent">SVG Templates & Presets</h2>
                                    <button onClick={() => setShowTemplates(false)} className="text-slate-400 hover:text-white"><X size={24}/></button>
                                </div>
                                <div className="p-6 space-y-8">
                                    <div>
                                        <h3 className="text-lg font-bold text-purple-300 mb-4">Individual Templates</h3>
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                            {SVG_TEMPLATES.map(t => (
                                                <div key={t.id} className="group relative cursor-pointer" onClick={() => { 
                                                    const els = parseSVGToElements(t.svg, false); // Don't group templates
                                                    if (els.length > 0) {
                                                        const containerW = containerRef.current?.clientWidth || 800;
                                                        const containerH = containerRef.current?.clientHeight || 600;
                                                        const centerX = (view.x + containerW/2) / view.zoom;
                                                        const centerY = (view.y + containerH/2) / view.zoom;
                                                        
                                                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                                        els.forEach(e => {
                                                            minX = Math.min(minX, e.x);
                                                            minY = Math.min(minY, e.y);
                                                            maxX = Math.max(maxX, e.x + e.width);
                                                            maxY = Math.max(maxY, e.y + e.height);
                                                        });
                                                        const groupCenterX = (minX + maxX) / 2;
                                                        const groupCenterY = (minY + maxY) / 2;
                                                        const offsetX = centerX - groupCenterX;
                                                        const offsetY = centerY - groupCenterY;
                                                        
                                                        const centeredEls = els.map(e => ({
                                                            ...e,
                                                            x: e.x + offsetX,
                                                            y: e.y + offsetY,
                                                            id: generateId()
                                                        }));
                                                        
                                                        setElements(prev => [...prev, ...centeredEls]);
                                                    } else {
                                                        addElement('svg-template', { templateId: t.id, templateSvg: t.svg, width: 120, height: 120 }); 
                                                    }
                                                    setShowTemplates(false); 
                                                }}>
                                                    <div className="bg-gradient-to-br from-slate-800 to-slate-700 rounded-lg p-4 border border-slate-600 hover:border-purple-400 transition-all group-hover:shadow-lg group-hover:shadow-purple-500/30">
                                                        <svg viewBox="0 0 100 100" className="w-full aspect-square mb-2" dangerouslySetInnerHTML={{__html: t.svg}} />
                                                        <p className="text-xs font-semibold text-slate-300 text-center group-hover:text-purple-300">{t.name}</p>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="pt-4 border-t border-slate-700">
                                        <h3 className="text-lg font-bold text-purple-300 mb-4">Preset Collections</h3>
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                            {SVG_PRESETS.map(p => (
                                                <div key={p.id} className="bg-gradient-to-br from-slate-800 to-slate-700 rounded-lg p-4 border border-slate-600 hover:border-purple-400 transition-all cursor-pointer hover:shadow-lg hover:shadow-purple-500/30" onClick={() => { p.templates.forEach(tid => { const t = SVG_TEMPLATES.find(x => x.id === tid); if(t) addElement('svg-template', { templateId: t.id, templateSvg: t.svg, width: 100, height: 100 }); }); setShowTemplates(false); }}>
                                                    <h4 className="font-bold text-slate-200 mb-2">{p.name}</h4>
                                                    <p className="text-xs text-slate-400">{p.templates.length} templates</p>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Toolbar */}
                    <div className="order-3 md:order-1 w-full md:w-20 bg-gradient-to-b from-slate-900 via-purple-900 to-slate-900 border-t md:border-t-0 md:border-r border-purple-500/30 flex flex-row md:flex-col items-center justify-around md:justify-start py-2 md:py-4 gap-2 md:gap-3 z-40 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] md:shadow-sm shrink-0 overflow-x-auto md:overflow-y-auto no-scrollbar">
                        <button onClick={() => setShowTemplates(true)} className="group p-3 rounded-xl transition-all duration-200 text-purple-300 hover:bg-purple-600/30 hover:text-purple-100 md:w-12 md:h-12 relative shrink-0" title="Templates">
                            <Layers size={20} className="group-hover:scale-110 transition-transform"/>
                        </button>
                        <div className="hidden md:block w-full h-px bg-gradient-to-r from-slate-600 to-transparent" />
                        
                        {/* Select Tool */}
                        <button onClick={() => setTool('select')} className={`p-3 rounded-xl transition-all duration-200 group relative md:w-12 md:h-12 shrink-0 ${tool === 'select' ? 'bg-gradient-to-br from-purple-500 to-pink-500 text-white shadow-lg shadow-purple-500/50' : 'text-slate-400 hover:bg-purple-600/30 hover:text-purple-200'}`} title="Select">
                            <MousePointer2 size={20} className="group-hover:scale-110 transition-transform"/>
                        </button>
                        
                        {/* Text Tool */}
                        <button onClick={() => addElement('text')} className="p-3 rounded-xl transition-all duration-200 group relative md:w-12 md:h-12 shrink-0 text-slate-400 hover:bg-purple-600/30 hover:text-purple-200" title="Text">
                            <Type size={20} className="group-hover:scale-110 transition-transform"/>
                        </button>

                        {/* Ungroup Tool (Contextual) */}
                        {selection && findElement(selection)?.type === 'group' && (
                            <button onClick={ungroupSelection} className="p-3 rounded-xl transition-all duration-200 group relative md:w-12 md:h-12 shrink-0 text-slate-400 hover:bg-purple-600/30 hover:text-purple-200" title="Ungroup (Ctrl+Shift+G)">
                                <Layers size={20} className="group-hover:scale-110 transition-transform line-through"/>
                            </button>
                        )}
                        
                        <div className="hidden md:block w-full h-px bg-gradient-to-r from-slate-600 to-transparent" />
                        
                        {/* More Shapes Dropdown */}
                        <div className="relative shrink-0 shape-menu-container">
                            <button onClick={(e) => { setShowShapeMenu(!showShapeMenu); e.currentTarget.getBoundingClientRect(); }} className="p-3 rounded-xl transition-all duration-200 group relative md:w-12 md:h-12 text-slate-400 hover:bg-purple-600/30 hover:text-purple-200" title="All Shapes">
                                <Menu size={20} className="group-hover:scale-110 transition-transform"/>
                            </button>
                            {showShapeMenu && (
                                <div className="fixed left-4 md:left-24 bottom-20 md:bottom-auto md:top-24 z-[9999] bg-gradient-to-br from-slate-800/95 to-slate-900/95 backdrop-blur-xl border border-purple-500/30 rounded-xl shadow-2xl p-4 min-w-[320px] max-h-[70vh] overflow-y-auto custom-scrollbar">
                                    <div className="grid grid-cols-2 gap-4">
                                        <div className="space-y-1">
                                            <h3 className="text-xs font-bold text-purple-300 uppercase tracking-wider mb-2 px-2">Basic Shapes</h3>
                                            <button onClick={() => { addElement('rect'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Rectangle</button>
                                            <button onClick={() => { addElement('circle'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Circle</button>
                                            <button onClick={() => { addElement('line'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Line</button>
                                            <button onClick={() => { addElement('triangle'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Triangle</button>
                                            <button onClick={() => { addElement('right-triangle'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Right Triangle</button>
                                            <button onClick={() => { addElement('parallelogram'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Parallelogram</button>
                                            <button onClick={() => { addElement('trapezoid'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Trapezoid</button>
                                            <button onClick={() => { addElement('pentagon'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Pentagon</button>
                                            <button onClick={() => { addElement('hexagon'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Hexagon</button>
                                            <button onClick={() => { addElement('octagon'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Octagon</button>
                                            <button onClick={() => { addElement('star'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Star</button>
                                        </div>
                                        <div className="space-y-1">
                                            <h3 className="text-xs font-bold text-purple-300 uppercase tracking-wider mb-2 px-2">Symbols</h3>
                                            <button onClick={() => { addElement('heart'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Heart</button>
                                            <button onClick={() => { addElement('diamond'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Diamond</button>
                                            <button onClick={() => { addElement('cross'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Cross</button>
                                            <button onClick={() => { addElement('check'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Check</button>
                                            <button onClick={() => { addElement('x-mark'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> X-Mark</button>
                                            <button onClick={() => { addElement('lightning'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Lightning</button>
                                            <button onClick={() => { addElement('cloud'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Cloud</button>
                                            <button onClick={() => { addElement('moon'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Moon</button>
                                            <button onClick={() => { addElement('speech-bubble'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Speech</button>
                                            <button onClick={() => { addElement('cylinder'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Cylinder</button>
                                            <button onClick={() => { addElement('cube'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Cube</button>
                                        </div>
                                    </div>
                                    
                                    <h3 className="text-xs font-bold text-purple-300 uppercase tracking-wider mt-3 mb-2 px-2 pt-2 border-t border-purple-500/20">Brackets & Symbols</h3>
                                    <div className="grid grid-cols-3 gap-2">
                                        <button onClick={() => { addElement('bracket-curly-left'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors">{'{'}</button>
                                        <button onClick={() => { addElement('bracket-curly-right'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors">{'}'}</button>
                                        <button onClick={() => { addElement('bracket-square-left'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors">{'['}</button>
                                        <button onClick={() => { addElement('bracket-square-right'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors">{']'}</button>
                                        <button onClick={() => { addElement('parenthesis-left'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors">{'('}</button>
                                        <button onClick={() => { addElement('parenthesis-right'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors">{')'}</button>
                                    </div>

                                    <h3 className="text-xs font-bold text-purple-300 uppercase tracking-wider mt-3 mb-2 px-2 pt-2 border-t border-purple-500/20">Arrows</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={() => { addElement('arrow-right'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Right</button>
                                        <button onClick={() => { addElement('arrow-left'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Left</button>
                                        <button onClick={() => { addElement('arrow-up'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Up</button>
                                        <button onClick={() => { addElement('arrow-down'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Down</button>
                                        <button onClick={() => { addElement('chevron-right'); setShowShapeMenu(false); }} className="w-full text-left px-3 py-2 rounded-lg hover:bg-purple-600/30 text-slate-300 text-sm transition-colors"> Chevron</button>
                                    </div>

                                    <h3 className="text-xs font-bold text-purple-300 uppercase tracking-wider mt-3 mb-2 px-2 pt-2 border-t border-purple-500/20">Style Presets (Applied to New Shapes)</h3>
                                    <div className="grid grid-cols-3 gap-2 px-2">
                                        <button onClick={() => setDefaultShapeStyle({ fill: 'none', stroke: '#3b82f6', strokeWidth: 2 })} className={`p-2 rounded border-2 border-blue-500 hover:bg-blue-500/20 text-[10px] text-center text-slate-300 ${defaultShapeStyle.fill === 'none' ? 'bg-blue-500/20 ring-2 ring-white' : ''}`}>Outline</button>
                                        <button onClick={() => setDefaultShapeStyle({ fill: '#3b82f6', stroke: 'none', strokeWidth: 0 })} className={`p-2 rounded bg-blue-500 hover:bg-blue-600 text-[10px] text-center text-white ${defaultShapeStyle.fill !== 'none' && defaultShapeStyle.stroke === 'none' ? 'ring-2 ring-white' : ''}`}>Filled</button>
                                        <button onClick={() => setDefaultShapeStyle({ fill: '#3b82f6', stroke: '#ffffff', strokeWidth: 2 })} className={`p-2 rounded bg-blue-500 border-2 border-white hover:bg-blue-600 text-[10px] text-center text-white ${defaultShapeStyle.fill !== 'none' && defaultShapeStyle.stroke !== 'none' ? 'ring-2 ring-white' : ''}`}>Both</button>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Crop Tool */}
                        <button onClick={() => setShowCropTool(true)} className="p-3 rounded-xl transition-all duration-200 group relative md:w-12 md:h-12 shrink-0 text-slate-400 hover:bg-purple-600/30 hover:text-purple-200" title="Crop Tool">
                            <Crop size={20} className="group-hover:scale-110 transition-transform"/>
                        </button>
                    </div>

                    {/* Main Canvas Area */}
                    <div className="order-2 flex-1 flex flex-col relative h-full overflow-hidden bg-gradient-to-br from-slate-900 to-slate-800">
                        <div className="h-16 bg-gradient-to-r from-purple-900 via-slate-900 to-slate-900 border-b border-purple-500/30 flex items-center justify-between px-6 z-10 shrink-0 shadow-lg shadow-purple-500/10">
                            <div className="flex items-center gap-4">
                                <h1 className="font-bold text-slate-100 tracking-tight flex items-center gap-3 text-base md:text-xl">
                                    <div className="w-8 h-8 bg-gradient-to-br from-purple-500 to-pink-500 rounded-lg flex items-center justify-center text-white text-sm font-bold">S</div>
                                    Canvas Studio <span className="text-[10px] px-2 py-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white rounded-md font-bold uppercase tracking-wider">Pro</span>
                                </h1>
                                <div className="hidden md:flex items-center gap-2 text-xs text-slate-400 border-l border-purple-500/30 pl-4 ml-2"><Upload size={14}/> Drop SVG or Templates</div>
                            </div>
                            <div className="flex items-center gap-2 md:gap-4">
                                <button onClick={() => setShowLayersPanel(!showLayersPanel)} className={`p-2 rounded-lg transition-all ${showLayersPanel ? 'bg-gradient-to-r from-purple-500/30 to-pink-500/30 text-purple-300 border border-purple-400/50' : 'text-slate-500 hover:bg-purple-600/20'}`} title="Layers"><Layers size={18}/></button>
                                <button onClick={() => setSmartGuidesEnabled(!smartGuidesEnabled)} className={`p-2 rounded-lg transition-all ${smartGuidesEnabled ? 'bg-gradient-to-r from-emerald-500/30 to-green-500/30 text-emerald-300 border border-emerald-400/50' : 'text-slate-500 hover:bg-green-600/20'}`} title="Smart Guides"><AlignLeft size={18}/></button>
                                <button onClick={() => setShowGrid(!showGrid)} className={`p-2 rounded-lg transition-all ${showGrid ? 'bg-gradient-to-r from-purple-500/30 to-pink-500/30 text-purple-300 border border-purple-400/50' : 'text-slate-500 hover:bg-purple-600/20'}`} title="Grid"><Grid size={18}/></button>
                                <div className="flex items-center bg-slate-800/50 rounded-lg p-1 border border-purple-500/20">
                                    <button onClick={() => setView(v => ({...v, zoom: Math.max(0.2, v.zoom - 0.2)}))} className="p-1.5 hover:bg-slate-700 rounded-md text-slate-400 hover:text-slate-200"><ZoomOut size={16}/></button>
                                    <span className="text-xs font-mono w-8 text-center hidden sm:block text-slate-300">{Math.round(view.zoom * 100)}%</span>
                                    <button onClick={() => setView(v => ({...v, zoom: Math.min(5, v.zoom + 0.2)}))} className="p-1.5 hover:bg-slate-700 rounded-md text-slate-400 hover:text-slate-200"><ZoomIn size={16}/></button>
                                </div>
                                <button onClick={() => setIsPlaying(!isPlaying)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all shadow-lg ${isPlaying ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white shadow-orange-500/50 hover:from-amber-600 hover:to-orange-600' : 'bg-gradient-to-r from-purple-600 to-pink-600 text-white shadow-purple-500/50 hover:from-purple-700 hover:to-pink-700'}`}>
                                    {isPlaying ? <Pause size={16} fill="currentColor"/> : <Play size={16} fill="currentColor"/>} <span className="hidden sm:inline">{isPlaying ? 'Pause' : 'Play'}</span>
                                </button>
                                <button onClick={handleExport} className="p-2 text-slate-400 hover:text-green-400 hover:bg-green-500/20 rounded-lg transition-all border border-slate-700 hover:border-green-500/50" title="Export SVG"><Download size={20} /></button>
                                <div className="flex items-center gap-1 ml-2 border-l border-purple-500/30 pl-2">
                                    <button onClick={handleSaveProject} className="p-2 text-slate-400 hover:text-blue-400 hover:bg-blue-500/20 rounded-lg transition-all" title="Save Project"><Download size={16} className="rotate-180"/></button>
                                    <label className="p-2 text-slate-400 hover:text-blue-400 hover:bg-blue-500/20 rounded-lg transition-all cursor-pointer" title="Load Project">
                                        <Upload size={16}/>
                                        <input type="file" accept=".json" className="hidden" onChange={handleLoadProject}/>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 relative overflow-hidden touch-none" ref={containerRef} onDrop={handleDrop} onDragOver={handleDragOver}>
                            <div className="absolute inset-0 pointer-events-none" style={{ backgroundSize: `${20 * view.zoom}px ${20 * view.zoom}px`, backgroundImage: showGrid ? `radial-gradient(#6366f1 0.5px, transparent 0.5px)` : 'none', backgroundPosition: `${view.x + (containerRef.current?.clientWidth || 800)/2}px ${view.y + (containerRef.current?.clientHeight || 600)/2}px`, opacity: 0.3 }}/>
                            <div className="w-full h-full" onMouseDown={handlePointerDown} onMouseMove={handlePointerMove} onMouseUp={handlePointerUp} onMouseLeave={handlePointerUp} onTouchStart={handlePointerDown} onTouchMove={handlePointerMove} onTouchEnd={handlePointerUp} onWheel={handleWheel}>
                                <svg xmlns="http://www.w3.org/2000/svg" ref={svgRef} width="100%" height="100%" viewBox={`${-view.x / view.zoom - (containerRef.current?.clientWidth || 800) / (2 * view.zoom)} ${-view.y / view.zoom - (containerRef.current?.clientHeight || 600) / (2 * view.zoom)} ${(containerRef.current?.clientWidth || 800) / view.zoom} ${(containerRef.current?.clientHeight || 600) / view.zoom}`} style={{ touchAction: 'none', background: 'transparent' }}>
                                    <defs>
                                        <style>
                                            {GLOBAL_STYLES}
                                            {elements.flatMap(el => (el.animations || []).map((anim, idx) => {
                                                if (anim.type === 'move') {
                                                    return `@keyframes move-${el.id}-${idx} { to { transform: translate(${anim.pathX}px, ${anim.pathY}px); } }`;
                                                }
                                                if (anim.type === 'morph' && el.type === 'polygon' && el.points) {
                                                    // For polygons, create a subtle morph by scaling
                                                    return `@keyframes morph-${el.id}-${idx} { 0% { transform: scale(1); } 50% { transform: scale(1.15) rotate(3deg); } 100% { transform: scale(1); } }`;
                                                }
                                                if (anim.type === 'morph') {
                                                    return `@keyframes morph-${el.id}-${idx} { 0% { transform: scale(1); } 50% { transform: scale(1.1) rotate(5deg); } 100% { transform: scale(1); } }`;
                                                }
                                                if (anim.type === 'color') {
                                                    const targetColor = anim.targetColor || '#ff0000';
                                                    const startColor = el.fill || '#000000';
                                                    // Handle gradient fills
                                                    if (el.fillType === 'gradient') {
                                                        return `@keyframes color-${el.id}-${idx} { from { opacity: 1; } to { opacity: 1; filter: hue-rotate(${anim.hueRotate || 180}deg) saturate(${anim.saturate || 1.5}); } }`;
                                                    }
                                                    return `@keyframes color-${el.id}-${idx} { from { fill: ${startColor}; } to { fill: ${targetColor}; } }`;
                                                }
                                                if (anim.type === 'textSize' && el.type === 'text') {
                                                    const startSize = el.fontSize || 24;
                                                    const targetSize = anim.targetSize || 40;
                                                    return `@keyframes textSize-${el.id}-${idx} { from { font-size: ${startSize}px; } to { font-size: ${targetSize}px; } }`;
                                                }
                                                return '';
                                            })).join('\n')}
                                        </style>
                                        <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%"><feDropShadow dx="0" dy="4" stdDeviation="6" floodColor="#000000" floodOpacity="0.15"/></filter>
                                        <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#a78bfa" /></marker>
                                        {elements.map(el => el.fillType === 'gradient' && (
                                            <linearGradient key={`grad-${el.id}`} id={`grad-${el.id}`} x1="0%" y1="0%" x2="100%" y2="100%">
                                                {(el.gradientStops || []).map((stop, idx) => (
                                                    <stop key={idx} offset={`${stop.offset}%`} stopColor={stop.color} />
                                                ))}
                                            </linearGradient>
                                        ))}
                                    </defs>
                                    {elements.map(renderElement)}
                                    {renderTransformGizmo()}
                                    {/* Smart Guides */}
                                    {activeGuides.map((guide, idx) => {
                                        if (guide.type === 'vertical') {
                                            return (
                                                <line
                                                    key={`guide-${idx}`}
                                                    x1={guide.x}
                                                    y1={guide.y1}
                                                    x2={guide.x}
                                                    y2={guide.y2}
                                                    stroke="#10b981"
                                                    strokeWidth={1.5 / view.zoom}
                                                    strokeDasharray={`${4 / view.zoom} ${3 / view.zoom}`}
                                                    className="ui-layer pointer-events-none"
                                                    style={{ opacity: 0.8 }}
                                                />
                                            );
                                        } else {
                                            return (
                                                <line
                                                    key={`guide-${idx}`}
                                                    x1={guide.x1}
                                                    y1={guide.y}
                                                    x2={guide.x2}
                                                    y2={guide.y}
                                                    stroke="#10b981"
                                                    strokeWidth={1.5 / view.zoom}
                                                    strokeDasharray={`${4 / view.zoom} ${3 / view.zoom}`}
                                                    className="ui-layer pointer-events-none"
                                                    style={{ opacity: 0.8 }}
                                                />
                                            );
                                        }
                                    })}
                                </svg>
                            </div>
                        </div>
                    </div>

                    {/* Inspector */}
                    <div className={`fixed md:static md:order-3 inset-x-0 bottom-[64px] md:bottom-0 z-30 bg-gradient-to-b from-slate-800 to-slate-900 border-t md:border-t-0 md:border-l border-purple-500/30 md:w-96 w-full md:h-full shadow-[0_-10px_40px_-15px_rgba(0,0,0,0.5)] md:shadow-none transition-transform duration-300 ease-in-out flex flex-col ${selectedEl && isInspectorOpen ? 'translate-y-0' : 'translate-y-[110%] md:translate-y-0'}`} style={{ maxHeight: '60vh', height: 'auto' }}>
                        <div className="flex border-b border-purple-500/30 bg-gradient-to-r from-slate-800 to-slate-700">
                            <button onClick={() => setActiveTab('layers')} className={`flex-1 py-3 text-xs font-bold uppercase tracking-wider transition-all ${activeTab === 'layers' ? 'text-purple-300 border-b-2 border-purple-500 bg-purple-600/20' : 'text-slate-400 hover:bg-slate-700/50'}`}>Layers</button>
                            <button onClick={() => setActiveTab('properties')} className={`flex-1 py-3 text-xs font-bold uppercase tracking-wider transition-all ${activeTab === 'properties' ? 'text-purple-300 border-b-2 border-purple-500 bg-purple-600/20' : 'text-slate-400 hover:bg-slate-700/50'}`}>Properties</button>
                            <button onClick={() => setActiveTab('timeline')} className={`flex-1 py-3 text-xs font-bold uppercase tracking-wider transition-all ${activeTab === 'timeline' ? 'text-purple-300 border-b-2 border-purple-500 bg-purple-600/20' : 'text-slate-400 hover:bg-slate-700/50'}`}>Timeline</button>
                            <button onClick={() => setActiveTab('svg')} className={`flex-1 py-3 text-xs font-bold uppercase tracking-wider transition-all ${activeTab === 'svg' ? 'text-purple-300 border-b-2 border-purple-500 bg-purple-600/20' : 'text-slate-400 hover:bg-slate-700/50'}`}>SVG Code</button>
                            <button onClick={() => setIsInspectorOpen(false)} className="md:hidden px-4 text-slate-400 hover:text-slate-200"><ChevronDown size={18}/></button>
                        </div>

                        <div className="flex-1 overflow-y-auto custom-scrollbar">
                            {activeTab === 'layers' ? (
                                <div className="p-4 space-y-2">
                                    <div className="flex items-center justify-between mb-4">
                                        <h3 className="text-xs font-bold text-purple-300 uppercase tracking-wider">All Layers</h3>
                                        <div className="flex gap-1">
                                            <button onClick={() => { if (multiSelection.length > 0 || selection) groupSelection(); }} className="px-2 py-1 text-xs bg-purple-600/30 hover:bg-purple-600/50 text-purple-300 rounded transition-colors" title="Group Selected">
                                                <Layers size={12}/>
                                            </button>
                                        </div>
                                    </div>
                                    {multiSelection.length > 0 && (
                                        <div className="bg-purple-500/20 border border-purple-500/30 rounded-lg p-3 mb-3">
                                            <div className="flex items-center justify-between">
                                                <span className="text-sm text-purple-200">{multiSelection.length} layers selected</span>
                                                <button onClick={() => setMultiSelection([])} className="text-xs text-purple-400 hover:text-purple-200">Clear</button>
                                            </div>
                                        </div>
                                    )}
                                    {elements.length === 0 ? (
                                        <div className="text-center py-12 text-slate-500">
                                            <Layers size={48} className="mx-auto mb-3 opacity-20"/>
                                            <p className="text-sm">No layers yet</p>
                                            <p className="text-xs mt-1">Add shapes to get started</p>
                                        </div>
                                    ) : (
                                        <div className="space-y-1">
                                            {[...elements].reverse().map(el => {
                                                const getLayerName = (element) => {
                                                    if (element.type === 'text') return element.text.slice(0, 20) || 'Text';
                                                    if (element.type === 'group') return `Group (${element.children?.length || 0} items)`;
                                                    if (element.type === 'polygon') return element.points?.length ? `${element.points.length}-sided Shape` : 'Polygon';
                                                    if (element.type === 'path') return 'Custom Path';
                                                    return element.type.charAt(0).toUpperCase() + element.type.slice(1);
                                                };
                                                
                                                return (
                                                    <div key={el.id}>
                                                        <div className={`p-3 rounded-lg border transition-all cursor-pointer ${multiSelection.includes(el.id) ? 'bg-purple-600/30 border-purple-500' : selection === el.id ? 'bg-purple-500/20 border-purple-500/50' : 'bg-slate-700/30 border-slate-600/30 hover:bg-slate-700/50 hover:border-slate-600/50'}`} onClick={(e) => {
                                                            if (e.ctrlKey || e.metaKey) {
                                                                if (multiSelection.includes(el.id)) {
                                                                    setMultiSelection(prev => prev.filter(i => i !== el.id));
                                                                } else {
                                                                    setMultiSelection(prev => [...prev, el.id]);
                                                                }
                                                            } else {
                                                                setSelection(el.id);
                                                                setMultiSelection([]);
                                                                setIsInspectorOpen(true);
                                                                setActiveTab('properties');
                                                            }
                                                        }}>
                                                            <div className="flex items-center justify-between">
                                                                <div className="flex items-center gap-2 flex-1">
                                                                    <div className="text-slate-400">
                                                                        {el.type === 'rect' && <Square size={14}/>}
                                                                        {el.type === 'circle' && <Circle size={14}/>}
                                                                        {el.type === 'text' && <Type size={14}/>}
                                                                        {el.type === 'line' && <Minus size={14}/>}
                                                                        {el.type === 'group' && <Layers size={14}/>}
                                                                        {(el.type === 'polygon' || el.type === 'path') && <Edit3 size={14}/>}
                                                                        {el.type === 'svg-group' && <ImageIcon size={14}/>}
                                                                    </div>
                                                                    <span className="text-sm text-slate-200 truncate">
                                                                        {getLayerName(el)}
                                                                    </span>
                                                                </div>
                                                                <div className="flex items-center gap-1">
                                                                    {el.locked && <Lock size={12} className="text-red-400"/>}
                                                                    {el.animations && el.animations.length > 0 && <Play size={12} className="text-green-400"/>}
                                                                    {el.type === 'group' && el.children?.length > 0 && <ChevronDown size={12} className="text-slate-400"/>}
                                                                </div>
                                                                </div>
                                                    </div>
                                                    {el.type === 'group' && el.children && el.children.length > 0 && selection === el.id && (
                                                        <div className="mt-2 ml-6 space-y-1">
                                                            {el.children.map(child => (
                                                                <div key={child.id} className="p-2 rounded bg-slate-800/50 border border-slate-700/50 text-xs text-slate-300 flex items-center gap-2">
                                                                    <div className="text-slate-500">
                                                                        {child.type === 'rect' && <Square size={12}/>}
                                                                        {child.type === 'circle' && <Circle size={12}/>}
                                                                        {child.type === 'text' && <Type size={12}/>}
                                                                        {(child.type === 'polygon' || child.type === 'path') && <Edit3 size={12}/>}
                                                                    </div>
                                                                    <span className="truncate">{child.type}</span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                    <div className="mt-4 p-3 bg-slate-700/30 rounded-lg border border-slate-600/30">
                                        <p className="text-xs text-slate-400 mb-2"><strong>Tip:</strong> Hold Ctrl/Cmd to select multiple layers</p>
                                        <p className="text-xs text-slate-400">Click the Group button to create groups</p>
                                    </div>
                                </div>
                            ) : activeTab === 'properties' && selectedEl ? (
                                <div className="pb-8">
                                    <div className="px-5 py-3 border-b border-purple-500/20 bg-gradient-to-r from-purple-900/30 to-pink-900/30 backdrop-blur flex justify-between items-center shrink-0">
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs font-bold text-purple-300 uppercase tracking-wider">{selectedEl.type}</span>
                                            {multiSelection.length > 0 && <span className="text-xs bg-purple-500/30 text-purple-200 px-2 py-0.5 rounded-full">{multiSelection.length} selected</span>}
                                        </div>
                                        <div className="flex items-center gap-1">
                                            <button onClick={groupSelection} className="p-2 rounded hover:bg-slate-700 transition-colors text-slate-500 hover:text-slate-300" title="Group Selection"><Layers size={16}/></button>
                                            {selectedEl.type === 'group' && (
                                                <button onClick={ungroupSelection} className="p-2 rounded hover:bg-slate-700 transition-colors text-slate-500 hover:text-slate-300" title="Ungroup"><Layers size={16} className="line-through"/></button>
                                            )}
                                            {(selectedEl.type === 'polygon' || selectedEl.type === 'path') && (
                                                <button 
                                                    onClick={() => {
                                                        if (editTool === 'points') {
                                                            setEditTool('none');
                                                            setEditMode(false);
                                                        } else {
                                                            setEditTool('points');
                                                            setEditMode(true);
                                                        }
                                                    }} 
                                                    className={`p-2 rounded hover:bg-slate-700 transition-colors ${editTool === 'points' ? 'text-green-400 bg-green-900/20' : 'text-slate-500 hover:text-slate-300'}`}
                                                    title="Edit Points"
                                                >
                                                    <Edit3 size={16}/>
                                                </button>
                                            )}
                                            <button onClick={() => updateElement(selectedEl.id, { locked: !selectedEl.locked })} className={`p-2 rounded hover:bg-slate-700 transition-colors ${selectedEl.locked ? 'text-red-400' : 'text-slate-500 hover:text-slate-300'}`}>{selectedEl.locked ? <Lock size={16}/> : <Unlock size={16}/>}</button>
                                            <button onClick={() => duplicateElement(selectedEl.id)} className="p-2 rounded hover:bg-slate-700 text-slate-500 hover:text-slate-300 transition-colors"><Copy size={16}/></button>
                                            <button onClick={() => removeElement(selectedEl.id)} className="p-2 rounded hover:bg-red-500/20 text-slate-500 hover:text-red-400 transition-colors"><Trash2 size={16}/></button>
                                        </div>
                                    </div>

                                    {selectedEl.type === 'text' && (
                                        <div className="p-5 border-b border-purple-500/20">
                                            <h3 className="text-xs font-bold text-purple-300 mb-2">Content</h3>
                                            <textarea rows={3} value={selectedEl.text} onChange={(e) => updateElement(selectedEl.id, {text: e.target.value})} className="w-full text-sm border border-purple-500/30 rounded-lg p-2 bg-slate-700/50 text-slate-100 focus:ring-2 focus:ring-purple-500 outline-none resize-none placeholder-slate-500" placeholder="Type text here..." />
                                            <div className="flex gap-2 mt-2">
                                                <select value={selectedEl.fontFamily} onChange={(e) => updateElement(selectedEl.id, {fontFamily: e.target.value})} className="flex-1 text-xs border border-purple-500/30 rounded p-1.5 bg-slate-800/90 text-slate-200 focus:ring-2 focus:ring-purple-500 outline-none"><option className="bg-slate-800 text-slate-200" value="Inter, sans-serif">Sans</option><option className="bg-slate-800 text-slate-200" value="Times New Roman, serif">Serif</option><option className="bg-slate-800 text-slate-200" value="Courier New, monospace">Mono</option></select>
                                                <input type="number" value={Math.round(selectedEl.fontSize)} onChange={(e) => updateElement(selectedEl.id, {fontSize: +e.target.value})} className="w-14 text-xs border border-purple-500/30 rounded p-1.5 bg-slate-700/50 text-slate-200" />
                                            </div>
                                        </div>
                                    )}
                                    
                                    {selectedEl.type !== 'line' && selectedEl.type !== 'image' && selectedEl.type !== 'svg-template' && selectedEl.type !== 'group' && (
                                        <div className="p-5 border-b border-purple-500/20">
                                            <div className="flex items-center justify-between mb-3">
                                                <h3 className="text-xs font-bold text-purple-300">Fill</h3>
                                                <div className="flex gap-1">
                                                    <button onClick={() => updateElement(selectedEl.id, {fillType: 'solid'})} className={`px-2 py-1 text-xs rounded ${selectedEl.fillType === 'solid' ? 'bg-purple-600 text-white' : 'bg-slate-700 text-slate-400'}`}>Solid</button>
                                                    <button onClick={() => updateElement(selectedEl.id, {fillType: 'gradient'})} className={`px-2 py-1 text-xs rounded ${selectedEl.fillType === 'gradient' ? 'bg-purple-600 text-white' : 'bg-slate-700 text-slate-400'}`}>Gradient</button>
                                                </div>
                                            </div>
                                            
                                            {selectedEl.fillType === 'solid' ? (
                                                <>
                                                    <div className="flex flex-wrap gap-2 mb-3">
                                                        {Object.entries(COLORS).map(([name, colors]) => (
                                                            <div key={name} className="flex gap-1">
                                                                {colors.slice(0, 3).map(c => (
                                                                    <button key={c} onClick={() => updateElement(selectedEl.id, {fill: c})} className="w-5 h-5 rounded-full border border-slate-600 hover:border-purple-400 transition-all hover:scale-110" style={{backgroundColor: c}}/>
                                                                ))}
                                                            </div>
                                                        ))}
                                                    </div>
                                                    <div><input type="color" value={selectedEl.fill} onChange={(e) => updateElement(selectedEl.id, {fill: e.target.value})} className="w-full h-8 rounded cursor-pointer border border-purple-500/30"/></div>
                                                </>
                                            ) : (
                                                <div className="space-y-3">
                                                    {(selectedEl.gradientStops || []).map((stop, idx) => (
                                                        <div key={idx} className="flex items-center gap-2 bg-slate-700/50 p-2 rounded-lg">
                                                            <input type="number" min="0" max="100" value={stop.offset} onChange={(e) => {
                                                                const newStops = [...(selectedEl.gradientStops || [])];
                                                                newStops[idx] = { ...newStops[idx], offset: +e.target.value };
                                                                updateElement(selectedEl.id, { gradientStops: newStops });
                                                            }} className="w-14 text-xs border border-purple-500/30 rounded p-1 bg-slate-700 text-slate-200" />
                                                            <span className="text-xs text-slate-400">%</span>
                                                            <input type="color" value={stop.color} onChange={(e) => {
                                                                const newStops = [...(selectedEl.gradientStops || [])];
                                                                newStops[idx] = { ...newStops[idx], color: e.target.value };
                                                                updateElement(selectedEl.id, { gradientStops: newStops });
                                                            }} className="w-8 h-8 rounded cursor-pointer border border-purple-500/30"/>
                                                            <input type="text" value={stop.color} onChange={(e) => {
                                                                const newStops = [...(selectedEl.gradientStops || [])];
                                                                newStops[idx] = { ...newStops[idx], color: e.target.value };
                                                                updateElement(selectedEl.id, { gradientStops: newStops });
                                                            }} className="flex-1 text-xs border border-purple-500/30 rounded p-1 bg-slate-700 text-slate-200" />
                                                            {(selectedEl.gradientStops || []).length > 2 && (
                                                                <button onClick={() => {
                                                                    const newStops = (selectedEl.gradientStops || []).filter((_, i) => i !== idx);
                                                                    updateElement(selectedEl.id, { gradientStops: newStops });
                                                                }} className="p-1 text-red-400 hover:bg-red-500/20 rounded"><X size={14}/></button>
                                                            )}
                                                        </div>
                                                    ))}
                                                    <button onClick={() => {
                                                        const stops = selectedEl.gradientStops || [];
                                                        const newOffset = stops.length > 0 ? Math.min(100, stops[stops.length - 1].offset + 20) : 50;
                                                        updateElement(selectedEl.id, { gradientStops: [...stops, { offset: newOffset, color: '#60a5fa' }] });
                                                    }} className="w-full py-2 text-xs bg-purple-600/30 hover:bg-purple-600/50 text-purple-300 rounded-lg transition-colors flex items-center justify-center gap-1">
                                                        <Plus size={14}/> Add Color Stop
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    <div className="p-5 border-b border-purple-500/20">
                                        <h3 className="text-xs font-bold text-purple-300 mb-3">Advanced Editing</h3>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => {
                                                    if (editTool === 'slice') {
                                                        setEditTool('none');
                                                        setEditMode(false);
                                                    } else {
                                                        setEditTool('slice');
                                                        setEditMode(true);
                                                        if (!selectedEl.slices) {
                                                            updateElement(selectedEl.id, {
                                                                slices: { x: { start: 25, end: 75 }, y: { start: 25, end: 75 } },
                                                                originalWidth: selectedEl.width,
                                                                originalHeight: selectedEl.height
                                                            });
                                                        }
                                                    }
                                                }}
                                                className={`flex-1 py-2 text-xs rounded-lg border transition-all ${editTool === 'slice' ? 'bg-purple-600 border-purple-500 text-white shadow-lg shadow-purple-500/30' : 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600'}`}
                                            >
                                                <Grid size={14} className="mx-auto mb-1"/>
                                                Smart Resize
                                            </button>

                                            <button 
                                                onClick={() => {
                                                    if (editTool === 'points') {
                                                        setEditTool('none');
                                                        setEditMode(false);
                                                        setSelectedPointIndices(new Set());
                                                    } else {
                                                        // Auto-convert rect to polygon if needed
                                                        if (selectedEl.type === 'rect' || (selectedEl.type !== 'path' && selectedEl.type !== 'polygon' && !selectedEl.points && !selectedEl.commands)) {
                                                            const pts = [
                                                                {x:0, y:0}, 
                                                                {x:selectedEl.width, y:0}, 
                                                                {x:selectedEl.width, y:selectedEl.height}, 
                                                                {x:0, y:selectedEl.height}
                                                            ];
                                                            updateElement(selectedEl.id, { type: 'polygon', points: pts });
                                                        }
                                                        setEditTool('points');
                                                        setEditMode(true);
                                                    }
                                                }}
                                                className={`flex-1 py-2 text-xs rounded-lg border transition-all ${editTool === 'points' ? 'bg-purple-600 border-purple-500 text-white shadow-lg shadow-purple-500/30' : 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600'}`}
                                            >
                                                <Edit3 size={14} className="mx-auto mb-1"/>
                                                Edit Points
                                            </button>
                                        </div>
                                        {editTool === 'slice' && (
                                            <div className="mt-3 text-[10px] text-slate-400 bg-slate-800/50 p-2 rounded border border-slate-700">
                                                Drag the pink lines to define the fixed corners. The center area will stretch.
                                            </div>
                                        )}
                                    </div>

                                    <div className="p-5 bg-gradient-to-br from-purple-900/30 to-pink-900/30 border-b border-purple-500/20">
                                        <div className="flex items-center justify-between mb-3">
                                            <h3 className="text-xs font-bold text-purple-300 flex items-center gap-2"><Play size={12} /> Animation Chain</h3>
                                            <button onClick={() => addAnimation(selectedEl.id)} className="p-1 rounded bg-purple-500/30 text-purple-300 hover:bg-purple-500/50 transition-colors"><Plus size={14}/></button>
                                        </div>
                                        
                                        <div className="space-y-4">
                                            {(!selectedEl.animations || selectedEl.animations.length === 0) && <p className="text-xs text-slate-500 italic">No animations added. Click + to add.</p>}
                                            {(selectedEl.animations || []).map((anim, idx) => (
                                                <div 
                                                    key={idx} 
                                                    draggable
                                                    onDragStart={() => setDraggedAnimIndex(idx)}
                                                    onDragOver={(e) => e.preventDefault()}
                                                    onDrop={() => {
                                                        if (draggedAnimIndex !== null && draggedAnimIndex !== idx) {
                                                            reorderAnimation(selectedEl.id, draggedAnimIndex, idx);
                                                        }
                                                        setDraggedAnimIndex(null);
                                                    }}
                                                    onDragEnd={() => setDraggedAnimIndex(null)}
                                                    className={`bg-slate-700/50 border border-purple-500/20 rounded-lg p-3 shadow-sm relative group cursor-move hover:border-purple-400/50 transition-all ${draggedAnimIndex === idx ? 'opacity-50 scale-95' : ''}`}
                                                >
                                                    <div className="flex items-center justify-between mb-2">
                                                        <div className="flex items-center gap-2">
                                                            <div className="text-slate-500 cursor-grab active:cursor-grabbing" title="Drag to reorder">
                                                                <Menu size={14}/>
                                                            </div>
                                                            <span className="text-[10px] font-bold text-purple-400 uppercase">Step {idx + 1}</span>
                                                        </div>
                                                        <button onClick={() => removeAnimation(selectedEl.id, idx)} className="text-slate-500 hover:text-red-400 transition-opacity"><X size={12}/></button>
                                                    </div>
                                                    <div className="mb-2">
                                                        <select value={anim.type} onChange={(e) => updateAnimation(selectedEl.id, idx, { type: e.target.value })} className="w-full text-sm font-medium border border-purple-500/30 rounded p-1.5 bg-slate-800/90 text-slate-200 focus:ring-2 focus:ring-purple-500 outline-none">
                                                            {ANIMATION_PRESETS.map(p => (<option key={p.id} value={p.id}>{p.label}</option>))}
                                                        </select>
                                                    </div>
                                                    <div className="grid grid-cols-3 gap-2">
                                                        <div><label className="text-[10px] text-slate-400">Duration (s)</label><input type="number" step="0.1" min="0.1" value={anim.duration} onChange={(e) => updateAnimation(selectedEl.id, idx, { duration: +e.target.value })} className="w-full text-xs border border-purple-500/30 rounded p-1 bg-slate-800/90 text-slate-200 focus:ring-2 focus:ring-purple-500 outline-none"/></div>
                                                        <div><label className="text-[10px] text-slate-400">Delay (s)</label><input type="number" step="0.1" min="0" value={anim.delay} onChange={(e) => updateAnimation(selectedEl.id, idx, { delay: +e.target.value })} className="w-full text-xs border border-purple-500/30 rounded p-1 bg-slate-800/90 text-slate-200 focus:ring-2 focus:ring-purple-500 outline-none"/></div>
                                                        <div>
                                                            <label className="text-[10px] text-slate-400">Easing</label>
                                                            <select value={anim.ease || 'ease-out'} onChange={(e) => updateAnimation(selectedEl.id, idx, { ease: e.target.value })} className="w-full text-xs border border-purple-500/30 rounded p-1 bg-slate-800/90 text-slate-200 focus:ring-2 focus:ring-purple-500 outline-none">
                                                                <option value="linear">Linear</option>
                                                                <option value="ease">Ease</option>
                                                                <option value="ease-in">Ease In</option>
                                                                <option value="ease-out">Ease Out</option>
                                                                <option value="ease-in-out">Ease In-Out</option>
                                                            </select>
                                                        </div>
                                                    </div>
                                                    {anim.type === 'move' && <div className="mt-2 text-[10px] text-green-400 bg-green-500/10 p-1 rounded border border-green-500/20">Drag green target #{idx+1} on canvas</div>}
                                                    {anim.type === 'morph' && <div className="mt-2 text-[10px] text-cyan-400 bg-cyan-500/10 p-1 rounded border border-cyan-500/20">Shape will scale and rotate smoothly</div>}
                                                    {anim.type === 'draw' && <div className="mt-2 text-[10px] text-purple-400 bg-purple-500/10 p-1 rounded border border-purple-500/20">Path strokes will animate drawing</div>}
                                                    {anim.type === 'color' && (
                                                        <div className="mt-2">
                                                            {selectedEl.fillType === 'gradient' ? (
                                                                <div className="space-y-2">
                                                                    <label className="text-[10px] text-slate-400">Gradient Shift</label>
                                                                    <div className="grid grid-cols-2 gap-2">
                                                                        <div>
                                                                            <label className="text-[9px] text-slate-400">Hue Rotate ()</label>
                                                                            <input type="number" value={anim.hueRotate || 180} onChange={(e) => updateAnimation(selectedEl.id, idx, { hueRotate: +e.target.value })} className="w-full text-xs border border-purple-500/30 rounded p-1 bg-slate-700/50 text-slate-200"/>
                                                                        </div>
                                                                        <div>
                                                                            <label className="text-[9px] text-slate-400">Saturate</label>
                                                                            <input type="number" step="0.1" value={anim.saturate || 1.5} onChange={(e) => updateAnimation(selectedEl.id, idx, { saturate: +e.target.value })} className="w-full text-xs border border-purple-500/30 rounded p-1 bg-slate-700/50 text-slate-200"/>
                                                                        </div>
                                                                    </div>
                                                                    <div className="text-[9px] text-cyan-400 bg-cyan-500/10 p-1 rounded border border-cyan-500/20">Gradient colors will shift dynamically</div>
                                                                </div>
                                                            ) : (
                                                                <div>
                                                                    <label className="text-[10px] text-slate-400">Target Color</label>
                                                                    <div className="flex gap-2">
                                                                        <input type="color" value={anim.targetColor || '#000000'} onChange={(e) => updateAnimation(selectedEl.id, idx, { targetColor: e.target.value })} className="w-8 h-8 rounded cursor-pointer border border-purple-500/30"/>
                                                                        <input type="text" value={anim.targetColor || '#000000'} onChange={(e) => updateAnimation(selectedEl.id, idx, { targetColor: e.target.value })} className="flex-1 text-xs border border-purple-500/30 rounded p-1 bg-slate-700/50 text-slate-200"/>
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                    {anim.type === 'textSize' && (
                                                        <div className="mt-2">
                                                            <label className="text-[10px] text-slate-400">Target Size (px)</label>
                                                            <input type="number" value={anim.targetSize || 20} onChange={(e) => updateAnimation(selectedEl.id, idx, { targetSize: +e.target.value })} className="w-full text-xs border border-purple-500/30 rounded p-1 bg-slate-700/50 text-slate-200"/>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            ) : activeTab === 'timeline' ? (
                                <div className="p-4">
                                    <div className="bg-gradient-to-br from-purple-600/20 to-pink-600/20 border border-purple-500/30 rounded-lg p-4 mb-4 text-center">
                                        <Wand2 size={24} className="mx-auto text-purple-400 mb-2"/>
                                        <h3 className="font-bold text-purple-300 text-sm mb-1">Auto-Sequencer</h3>
                                        <p className="text-xs text-purple-200/70 mb-3">Instantly arrange all animations to play one after another.</p>
                                        <button onClick={autoSequenceAnimations} className="bg-gradient-to-r from-purple-600 to-pink-600 text-white text-xs font-bold py-2 px-4 rounded-lg hover:from-purple-700 hover:to-pink-700 w-full transition-all shadow-lg shadow-purple-500/30">Apply Sequence</button>
                                    </div>
                                    <h3 className="text-xs font-bold text-purple-300 mb-3 flex items-center gap-2"><Clock size={12}/> Global Timeline</h3>
                                    <div className="space-y-2 relative">
                                        <div className="absolute left-3 top-0 bottom-0 w-px bg-purple-500/30 z-0"></div>
                                        {elements.flatMap(el => (el.animations || []).map((anim, idx) => ({ el, anim, idx }))).sort((a, b) => a.anim.delay - b.anim.delay).map(({ el, anim, idx }, i) => (
                                            <div key={`${el.id}-${idx}`} className="relative z-10 bg-gradient-to-r from-slate-700/50 to-slate-600/50 border border-purple-500/20 rounded-lg p-3 shadow-sm ml-6 hover:border-purple-400/50 transition-all cursor-pointer" onClick={() => { setSelection(el.id); setActiveTab('properties'); }}>
                                                <div className="absolute -left-8 top-1/2 -translate-y-1/2 w-3 h-3 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 border-2 border-slate-800"></div>
                                                <div className="flex justify-between items-center mb-1">
                                                    <span className="text-xs font-bold text-slate-200 truncate max-w-[120px]">{el.type === 'text' ? (el.text.slice(0,10) || 'Text') : el.type}</span>
                                                    <span className="text-[10px] font-mono text-slate-400">@ {anim.delay}s</span>
                                                </div>
                                                <div className="flex items-center gap-2 text-xs text-purple-300">
                                                    {anim.type === 'move' ? <Move size={12}/> : anim.type === 'morph' ? <Sparkles size={12}/> : <Play size={12}/>}
                                                    <span className="capitalize">{anim.type}</span>
                                                    <span className="text-slate-400">({anim.duration}s)</span>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ) : activeTab === 'svg' ? (
                                <div className="p-4 space-y-4">
                                    <div>
                                        <h3 className="text-xs font-bold text-purple-300 mb-2 flex items-center gap-2"><Code size={12}/> SVG Source</h3>
                                        <textarea value={selectedEl.svgData || ''} readOnly className="w-full h-40 text-xs border border-purple-500/30 rounded-lg p-2 bg-slate-700/50 text-slate-300 font-mono resize-none custom-scrollbar" />
                                    </div>
                                </div>
                            ) : (
                                <div className="flex flex-col items-center justify-center h-full text-slate-400 p-8 text-center">
                                    <div className="w-20 h-20 bg-slate-700/50 rounded-full flex items-center justify-center mb-4"><MousePointer2 size={32} className="opacity-20"/></div>
                                    <h3 className="font-semibold text-slate-300">No Selection</h3>
                                    <p className="text-sm mt-1 text-slate-500">Select an object to edit.</p>
                                </div>
                            )}
                        </div>
                    </div>

                    {showCropTool && (
                        <CropStretchModal 
                            onClose={() => setShowCropTool(false)} 
                            onSave={handleCropToolSave} 
                        />
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CanvasStudioUltimate />);
    </script>
</body>
</html>